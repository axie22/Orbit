title,video_id,transcript,filename
Google Coding Interview With a Google Software Engineer,Ebyesd3mPAA,"Kind: captions Language: en Google has less than a 1% acceptance rate, meaning it's statistically easier to get into Harvard University than Google. So, in today's video, I'm pulling back the curtain and I'm sitting down with an ex Google software engineer to find out how he actually cracked the notoriously difficult interview. And to really put his skills to the test, I'll challenge him with the real coding question from a past Google interviews so we can see firsthand what sets him apart into the elite 1%. And as you're watching this video, I want you to try solving the question on your own. It's not going to be easy, but that's the point. When I present the problem, pause the video, take a few minutes to attempt a solution and then come back and see how the Google software engineer tackles it step by step. But also, he's not just a Google software engineer. He's worked at Amazon and Uber and now he's leading a team at a fast growing startup. So, there's a lot of wisdom to unpack here. And with that being said, let's dive right in. Hey Kurt, how are you doing today? Hey, I'm doing very well. So, how are you? I'm good. I'm good. So today we're going to be going over a technical interview with you. I'm going to give you a coding problem and you're going to have about 20 to 30 minutes to solve it. Most importantly, I want to hear how your thought process is throughout this and whether you get the solution or not, just communicate effectively throughout this. Are you ready to get started? Yeah, that sounds good to me. This is the problem. I'm going to paste it right here. Given a string S, an array of string words, return the number of words I that is a subsequence of S. A subsequence of a string is a new string generated from the original string with some characters can be none deleted without changing the relative order of the remaining characters. For example, ACE is a subsequence of ABCDE. So one example that I'll provide for you is with the string abcde e and word array of a bb acce will have an output of three because the subsequence that can be formed are with the strings a acd and acce b as you can tell cannot be a subsequence of the string. Let me know if you have any questions about this or if you can understand example two as well. So, what are your first thoughts? Yeah. No, this makes a lot of sense. I do have a couple of questions. Um, so if I have A, B, C, D, E. Um, okay. So, A makes sense because it's the first letter and then we have BB and because there's and because you can't repeat any characters, BB doesn't work. Mhm. And then AC works because um all of those exist in that order. Um so that makes sense. And then um ACE also works for that same reason. Mhm. So that also makes sense. Um, one question that I had is that can there be capital letters or can I assume lowercase only? You can assume lowerase only. That's a good question. Okay. And another question that I had was regarding inputs. Can we have numbers, negative numbers, integers, things like that? Or even extraneous characters such as like parentheses or no? Uh, you can assume you'll have proper only lowercase English letters. It could potentially be an empty string, but otherwise they're all going to be normal. Okay. An empty string would result in a zero. Yes. Okay, cool. That sounds good to me. Um I guess for a brute force solution I'm thinking that one way we could do this is say for example abcde e this would result in um we could calculate all possible substrings. So, a a b a c um a d a e and then also b c bd. You get the idea, right? And then put those in a set and then compare if we have valid inputs um given our words list. So, I'll write that down. Um but that kind of seems like a slow solution to me and I know that we can do much better but um so calculate all possible substrings then compare um with words list and this should be I believe that calculating all possible substrings is the 2 to the n operation. Um where n is size of s. Um and s is what the string right? Yes. S equals strings and n is what? Where n is equals to the size of s. Okay. Does that make sense? Yes. Okay. Cool. Um so that would be the brute force solution. I think another possible solution that I'm thinking of is that we premputee um location of letter to um index. So for example we could do taking example of A B A C. We could have a hashmap of A and that would have values of zero and two and then we would do B which would be 1 and then C which would be three. And that would essentially give us a hashmap to be able to check very quickly of all the locations of the letters. And then we could go through the words list and essentially check the hashmap to see if we have a valid um subsequence. So could you actually like put an example of the inner workings of this structure um what you're talking about? Yeah, exactly. So I can do that right now. So take for example a b a c right. So this would result in a hashmap of a with values of one and two zero and two and then b which would result in values of one and then c which would be three. Does that make sense? And then yeah, we would go through the words list and check the first substring which is say we want to check a a right then we would go through the map and then for each word in the word list we would go oh there's a a and the zero so zero and then we would check we would delete that zero into the hashmap. So the next iteration would be a goes to just two and then we would find two right and then okay that since we can go through all characters this would result in valid. Mhm. Does that make sense? Yeah. And what do you think the time complexity of this is? the time complexity. So the first premputee would be O of S and then for each word we have to go into so it would be um the essentially words the len of each word because each letter we're going into the hashmap which is O of one check. Um but this yeah so essentially like but this should be one question about that one question about that is um in the case where we have essentially like a of zero and a of two so you have one key mapping to two values um when you we are deleting one of those values depending on what structure is being used there uh would that result in additional time complexities or no? Yeah. So depending on the structure it would um because a list like it shifts the elements things like that um and it also resizes um but we could also use like a like a a Q or a stack and then that would mitigate that problem because it's built on a linked list or something. Okay. Okay. Um, sounds good. And since we're just adding to the end and then popping from the beginning, that should be fine. So that's usually a stack. Okay. And that will keep it O of one, right? Yeah. Perfect. Cool. Sounds good. Okay. So I'll start by coding up the um the optimized solution that we just discussed to this problem. Find um number of subsequence and this will take in self. It doesn't need to take itself because we're not in a class. But um and then so first things first, we need to calculate our index map. And this will go through each um car in s character in s and then map of character. So first I'll check if the character actually exists. Mhm. And this will be if it does then we get the list current index list equals um next map of character equals equals. Okay, now we have current list current index list.append and then um so we actually need the index here. So I in in enumerate and what does the enumerate function do? So the enumerate function it gives us the index the essentially the index and the value. So it's index value. Perfect. Okay. Yeah. And then so now because we have both we can append the index here. So I and then we add it back to our list our map. Sorry, I thought we were using a stack or a queue like you had mentioned. Are we not doing that? Yeah, we can do that. Um, okay. What is the import for a stack? So, I don't know if Python has a built-in stack, but um, do you know the import for the stack? um syntax. So you can just in this case for the sake of this interview you can just pop on zero uh like just use the list but pop zero. Um but I'll just assume that we use stack. So we don't have to like worry too much about the complexities. I more care about your thought process. Okay, sounds good. Yeah. So now we have that and then if character and index map. So now okay so else that means it doesn't exist. Then we create our current index list equals and then and then okay cool. So now we have our pre-commuted index map and then now we just need to go into our map and then um go into each word for word and words and then we need a counter of words equals zero. And then we'll be returning that here. And then for word word compute if valid which will take in the word and then we'll take in um the index map and then if then plus = one. Okay. So now we just need to initiate this method and then once we do that the solution should work. Okay. So now we have the word and then we have the index map. One thing that I'm worried about is that we should create a copy of like a deep copy of the index map every time we pass it in. Um so we're making sure that we're not changing it. Um but we can do that in this function here. So index map um copy equals deep copy of index map and then so now because I'm pretty sure in Python you pass by reference. Mhm. So now what I need to do is I just need to go through the map for each word. Um go through each character and check if that's in the hashmap. Okay. So for character in um and I also need to keep track of the index of letter. Okay. For character in word actually. So if um in the index so we're checking the index um if the character exists um and if it doesn't then we just return false. Mhm. So if it exists then we need to pull the index. So index of current character equals index map copy of character and the index of the current character that we pull has to actually be greater than the index of the letter. And why is that? So say for example um because subsequence maintains the order of the string, right? So say for example we have a b um and then in words we have a string of a or ba. Mhm. So we need to make sure that b um when we're checking the next a we need to make sure that it came before the b. Right. Correct. To maintain the order. Yes. Okay, cool. Okay. Um, and there is a chance we might have to um go through the list in the hashmap because if you have ABA, we would actually want to return true here. But the hash the list will first contain the zero. But this should still return true because the A exists after. Mhm. Does that make sense? Yeah. Okay. So in that case we actually cannot use a stack. Okay. So the list is correct. Mhm. Okay. Cool. Um Okay. Index of current character index copy map. Okay. Um, okay. So now I have the current character and I need to check if the index of letter is um so okay so if I b [Music] a b was equal to one okay so index previous letter is that has to be less than current. Actually in order to find find index character we will take in the character and the index map copy. So you're creating another function. Yeah. Okay. Instead of this. Mhm. So this will actually give us the um character that is after the last character that we had. um and this will take in the index of previous letter. So now we want to find the index of the character. So we're going to get the list of character um copy of And then four. So this we can also do binary search here. Um and I can implement that later but for now I'll just do the easier solution. um for the sake of time because I want to get the correct solution out first. For index if um of previous letter is greater than index. So yeah, then you want to continue or we can just do less than here. Return of one else. Then we equals two. He Okay. [Music] Um and then if you go through all this return true here. Cool. Okay. I think they should work. Okay. Sweet. Um are you ready to test it out? Yeah. Okay. Um, I'll give you the Can you write out the function that you're going to call and then I'll put put in the inputs? [Music] Yeah, this is the function I would call. Okay. Right here. Okay, cool. Let me uh put in the inputs. So, first you have S, right? Mhm. So we'll say s equals a b cde e and words equals of a bb aca words. Yeah. Um, print that. Okay, let's run it. Invalid text. Oh, what do you think you forgot here? Um, oh, the colon. Perfect. Let's try running it again. Yeah. So I think I need to import the deep copy module. I think the way it's actually done is we import copy and then here we do copy deep copy. Um and I think that should work. Um but yeah, let's see if we got any other errors. Do you want to run it? Yeah. Here I'll hit run. Perfect. Cool. Uh I want to try out another test case. Okay. All right, let's run this. Perfect. Two. Cool. Uh, did you handle the empty string scenario? I believe so. It should work. Okay, cool. Now, uh, what you don't have to code this part out, but what are ways that you might enhance this or make it better? Yeah. So one of the things that I mentioned earlier was the function find index of character. It is actually linearly checking um the list which is already ordered which is inefficient because that's O of N and we could do better than that by doing binary search which would be login time. So that is one improvement that I would make right away. Other than that, um I think that it runs pretty efficiently and we're using um optimal space as well. But other improvements that I would make would be like more exception handling um to make sure that if there's invalid input. I know we mentioned that there wouldn't be but just in case that the user puts in malicious input that we have checks for that. Mhm. So those were some things that I would change. Awesome. Well Karen, you did a really awesome job and you completed it within time. Do you have any questions for me before we conclude? What's been your favorite project at this company? My favorite project at Google is working on the YouTube team on my YouTube channel. So, if you guys are watching, make sure to hit the subscribe button and like to support my project work. I'll see you guys next time.",Google Coding Interview With a Google Software Engineer [Ebyesd3mPAA].txt
Spotify Software Engineer Mock Interview： Merge k Sorted Linked Lists,cN4JCxBZcM4,Kind: captions Language: en you are given an array of k linked lists and each linked list is sorted in ascending order merge all of the linked lists into one sorted linked list [Music] hi everyone we're here today for another exponent mock interview with simon for those of you who aren't already familiar with exponent exponent helps you get your dream tech career with our online courses expert coaching peer-to-peer mock interviewing platform and interview question database check it out at tri-exponent dot com all right thanks so much for being here with us today simon uh would you quickly introduce yourself to our viewers sure so hi everyone my name is simon eisemann and i'm currently a senior software engineer at spotify working on a full stack ad tech product and prior to my current role i received an mba and a master's in computer science from the university of chicago and in the past i've worked as an engineer at etsy bloomberg and foursquare and i'm excited to be here awesome it's really great to have you here today thank you so let's get right into it so the question today is you are given an array of k linked lists and each link list is sorted in ascending order merge all of the linked lists into one sorted linked list could we maybe have an example of what the input looks like like just a sample set of linked lists okay so let's say that you're in your input you have three separate linked lists okay uh you have one to four to five you have uh one two three to four and you also have two to six um so then your output um would probably be you start with it once then you have a two three there are two fours a five and a six right does that make sense yeah that makes sense uh i guess one question i have is can we assume that uh all the inputs here are well formed or i guess to put it differently uh could i have potentially null lists inside of this input yeah you might have no lists got it okay so we'll probably need to take care of that uh when we get to the implementation yeah definitely yeah i guess another question i have is i noticed that in this input uh you have sort of like duplicate values here um one question i'd have about that is does the relative ordering of the nodes sort of matter when the node values are equal so basically for example like would i take a node from an earlier list if it's the same no it doesn't matter either one is fine got it okay all right so in which case that i think that gives me like a basic idea of maybe how i'd approach it um there's definitely like a brute force i think of that like comes to mind first uh the fact that it is like a series of linked lists kind of complicates it maybe a little bit for the brute force it versus if i have maybe the data in arrays for example um but one brute force approach that kind of comes to mind is i could basically take all the numbers put them inside one sort of larger non-linked list sort that list and then basically build a new linked list out of that okay yeah that makes sense so what would the run time for something like that be yeah yeah so unfortunately the runtime of that would be something like o of n log n because we're basically sorting on n elements where n is sort of all the number of all the elements in the list but that sort of seems a little slow given what the nature of the problem looks like yeah so do you think that you might be able to improve upon that then yeah i think we probably could um one thing that maybe i'd ask again to like clarify is is it okay if we modify the input list or am i sort of required to build an entirely new link list um yeah you can you can modify the input list if you'd like so let's take a look at the input maybe we can sort of get some ideas for how to improve this so if i sort of have these as my inputs i mean one thing i sort of noticed right off the bat that's like useful for us i think is that all of the lists themselves are in sorted order yes so like the benefit of that i think is we sort of have already like a look into what the candidates are to start us off in this sorted linked list um it sort of gives us the next smallest values because as we can see with this example with this example it's sort of at the front of each of the lists right um so i guess maybe one thing that kind of comes to mind is uh i start with the front nodes of each list i sort of like keep track of where i am inside of each list then i figure out what the smallest one of those three current nodes are and then i sort of attach it to some sort of like a result list and i just have to make sure to keep track of the nodes in each list as i go and we basically repeat the operation until we run out of nodes so for example if i kind of have this as as a as a starting example let's say like here i have some pointers for where i am inside of the list i sort of evaluate what's the smallest one out of all these so it's 1 1 let's say the first one is the smallest so i kind of add that to my list and then i move over the pointer inside of that linked list then i evaluate again what's the smallest node inside of these pointed two nodes and again it's the one inside of the second list so then that gives us the next node uh then that moves forward and then we do the same operation again so two would be the smallest out of these three three nodes so that gives us here and then so on and so forth um we just kind of have to make sure that we we take care of the case where we sort of end the list early perhaps to make sure that we're not going back over these sort of null nodes but essentially like that that can give us a fully sorted list yeah that makes a lot of sense um so now how complex is this yeah so we have to go over the nodes at least once so i think that would be minimum of n but if we have something like k lists then it would be something like o of n times k because we have to sort of iterate through all of the nodes and then at each of those stages we have to determine what the smallest front node is which is k so it'd be n of n times k yeah because you're comparing uh the head notes for k different lists at each step so right exactly so does that seem like the most efficient way to deal with that we do we can still leverage the fact that they're sorted but let's sort of think through what the steps are here so we we track each list or each node in the list we uh for for each you know or basically we iterate over each node and then we determine you know find the minimum element out of all k lists so it'd be something like that but that's still of n times k is there something here we could potentially improve i guess one thing that comes to mind is that when we find the minimum we sort of keep going back over the same nodes in some sense so like for example when we sort of started off we were kind of checking one one two and then when we moved over this one ahead uh we kind of keep going over some of the same elements that we had before yeah so maybe we can improve that yeah so i think actually a new approach is kind of coming to mind where maybe we can use something like a priority queue to improve this you know since at each step we're kind of going over the same elements what we could do is we can kind of keep track of the minimums as we go and at each iteration we basically add reinsert the new node that we have but we can still sort of get the smallest node that we have at any given time and i think the improvement there is so long as we keep the size of the priority queue the size of the number of the list so k lists we can improve the time complexity to n times log k so we'll ensure that the priority queue size never exceeds okay right that makes sense especially because that means that then for any pair of notes that you see once you've compared them once and they're stored that way in the priority queue so you don't have to compare them again right right exactly yeah awesome okay so that approach sounds really good to me great all right let's let's implement something yeah um so do you have like a basis for what the the uh list node class looks like i mean it probably has like a next pointer and like a value do do we have some access to something like that yeah so you can either write your own or i can copy something over for you um you can just assume that like it just stores a value and a pointer to the next node okay great uh so we'll just reintroduce it in later in case we need to um in case we need to use it but it'll be something like uh it'll have a value and a next pointer like you mentioned yep all right so large k lists so basically what we have is uh the input which would basically be a series of lists so something like this um i guess just so we kind of have our ducks in a row we have to take care of the situation where maybe it's empty so if the length of the list equals zero then we simply return none i suppose right that'd be fair we kind of want to keep keep track of that um something else we need to do is we need a new head so that'd be the new head of our final list we can initialize that to be none i guess we'd have to probably initialize our priority queue right so pq equals um q dot priority queue let's make sure to import that appropriately great and now we actually have to populate it so the first thing we do is uh for list head lists we have to do something like uh pq pq dot put um we want these properly sorted so i'm going to put a a tuple essentially so our entry will be something like the list head value and we want to keep track of the note itself so what we can do is put the list the note itself with us as we go and then essentially we just put this inside so that sort of starts us off with where we are inside of the priority queue and now we just have to kind of go over the entries and make sure we kind of keep going forward at the priority queue so while the priority queue is uh not empty well it's not empty we get the entry so it would be node value node pq dot get we can sort of start to initialize ourselves properly so what we actually should probably do is we should also keep track of where we are in the result list so we actually probably want another node uh we can strut that off as none as well and just for readability i'll actually probably put these together right so we have something like this um what we want to do is we basically want to uh take that and append it to our resulting list now we already know at this point that this gives us the minimum the minimum value node so that's good and like you mentioned before we don't need to keep track of the relative ordering so um we kind of don't need to take care of that case if maybe we wanted to keep track of the relative ordering i may have added uh like an like an index or something here uh that that can help us keep track of the nodes but since that's not the case we don't we don't really need to do that so one thing that i want to do here is um basically if if our new head is none right that tells us that we haven't yet initialized the list and if we haven't yet initialized the list then we actually have to sort of you know create that that new node essentially so uh we would do something like new head uh equals node and we have to do something similar to this so that kind of keeps track of where we are lists right yeah and the resulting lesson just to kind of make that clear as to what we're doing we kind of return the new head at the end okay uh so so new hand always points to the beginning of the result list and current node always points to the end there's a list yes like the current end essentially yeah okay now we're back to this case so if the new head is not none then what we basically have to do is we have to set current nodes next to be the node's next value so what that tells us is that currentnode.next equals maybe node.next i think we may need to change that a little bit or uh yeah we may need to change that but uh then we have to just make sure that we move forward in the list um so that would just be node right so that kind of tells us like where where we are inside of our resultant list now we may actually need to do a little bit more logic here because it might give us like a null pointer exception or you know basically a none doesn't have a next sort of error i was also wondering why are we setting um the next value of the result list to the next of like this current node because it might be something else in the priority queue should be the next one right right exactly um i guess what we haven't done yet though is that well at this point we kind of have the minimum value node so we kind of know that whatever we had previously we're currently putting the next smallest node next to it um so this kind of gets us to the very end of the list but actually one thing that we're not doing here though is that we're not actually adding to our priority queue because that's that's also something that we want to do yeah so so actually what i'll do is um i'll kind of make it a little nicer so i'll do next node is node.next um and what we want to make sure is that that's actually not none right we want to make sure that it's good for us to use so if next node is not none then what we do here is we basically figure out what the next value is so we have a new entry here and our new entry would be [Music] next no dot val and next node and then we put the entry inside of the the priority queue itself and i think overall that looks good to me let's take a look at this uh well i mean one thing that sort of comes to mind is like if i wanted to if i wanted to test this like to make sure it's right i'd probably start to write unit tests right around now or have some sort of example scenarios um to make sure that the code works um and we definitely want to include corner cases there so i actually now you you mentioned at the beginning that we can have like the the input is not always well formed so it might be none sometimes uh and i actually don't take care of that situation up here when i when i initialize it so let's actually just make sure that that's valid so um if list head is not none then we can do all that and that actually helps us avoid some cases yeah so the section so this uh resolves that situation maybe let's write like a function that kind of helps us test this can we actually i would love to see you run the code on some test cases yeah for sure so if if we want to run the code then we we should uh initialize a listnode class so let's let's do that that kind of helps us there if we wanted to write a unit test framework we why don't we start with the example that we had at the very outset where we had like one points to two uh we can kind of probably re-replicate it again but it's like one points to two points to four points to six or something like that so list one equals list node we can do it one and then none actually why don't we be recursive about it like they can kind of help us uh be a little clearer as to which list is which so so one uh let's say four six let me just write none so that's our first list and uh just for argument's sake let's also add a nun a nun case in there where it's just list four equals none just to make sure that we're kind of keeping our bases covered yeah i'm that you're testing the corner cases yeah and if i wanted to have like a more robust set of unit tests like i would have a completely empty case you know a case where it was just all none something like that but just to make sure that the core of our code works like we'd probably want to test something like this so um we want to merge k lists and we do list one list two list three list four and that gives us basically the merged head and we're just going to have some testing code here where we kind of iterate through it and maybe print the value so so current node is merged head while current node is not done iterate forward and then all we can do is just print so it would be something like node dot val and then just to make it pretty we'll sort of add an arrow with a space right not supported uh yes okay so basically the the issue that it's talking about here is the fact that um our list nodes can't be properly compared when we're sort of keeping nodes in there um so even though we're sort of comparing the values you know there are a couple of ways we can deal with this maybe we might say that it's on purpose that this is the case and should actually only be storing values inside of our priority queue and we can sort of regenerate the list if we want but i'll actually maybe implement something here inside of the list node that basically makes it okay for us to compare list node values so it would be something like uh the quality operator um self and other and basically what we're sort of doing here is we want to compare let's say just the values for now so something like uh self you know return self.val uh equals other.now just for simplicity's sake and we want to kind of do something similar for the less than case because that's kind of it's probably going to yell at us about that too so so i think this should do it okay perfect yeah that looks great to me all right so let's run it again uh yes it sort of gives it to us as sort of like a new a new series of lists so um what we want to do here is maybe instead of printing actually this this might be okay because this kind of still tells us what the next note in the list is but one thing that i notice here is that uh the one the three and the six it's sort of like not not quite giving us what we want um yeah i think it's skipping every other one um and i think the reason for that might be the way that you've like set the next node for the um so like on line 41 yeah yeah at the end you've set the next node to be the you're skipping yeah exactly yeah yeah so that was like the one thing that we ended up skipping yeah this is what you brought up earlier when you said that i was kind of saying it incorrectly but i didn't quite quite take that hint so i appreciate that thank you um so let's let's try it again let's see if it kind of gives us a completely merged list all right great so one two one two two three four four six seven great so this this looks like it works yeah we can probably write more unit tests if we'd like but i think this probably covers the bulk of cases and it doesn't have a null pointer exception so that's good okay awesome yeah so thanks so much for joining us for this interview you did a fantastic job so i think this is a good place for us to pause and analyze the interview a little bit um what do you think went well for you in this interview and what would you want to improve on yeah i think one of the things uh is that you know i started by sort of giving a brute force approach uh to solve the problem and there's nothing inherently wrong with that maybe but kind of my next step after that was i didn't quite get to a fully performance solution um we sort of kind of had a little bit more of an improvement but it wasn't quite the best but thankfully we sort of went through some of the examples and i think that that kind of helped us see what we could potentially improve on specifically in our case it was finding the minimum so maybe getting to that step a little bit faster and intuiting that maybe using a priority queue would have helped us a little sooner would have been better um another thing that i probably could have done better is i did still have some corner cases that weren't quite accurate i wasn't traversing accurately like you mentioned on line 41 correctly so that was something i probably could have caught a little bit earlier but maybe what was good though is that uh there were still some other corner cases that i did catch while i was going through the code and kind of tracing through it when it was basically done so for example when the list node is none we probably don't actually want to add that to the priority queue that will probably break our code yeah yeah yeah i agree with a lot of those points and you mostly focus on things that you could improve on but i thought that there was plenty that you did really well also so for example um i actually really like that you started off with the brute force solution and like logic your way to the more optimal solution because at each stage you were able to identify what was inefficient about the previous solution um so for example like um you mentioned that we should take advantage of the um the structure in the input so uh specifically the fact that the linked lists that you get are ordered whenever you get any sort of structure like that in the input you should always take advantage of it right so i really like that you explicitly mentioned that and then also uh you identify the inefficiency where you're comparing um pairs of nodes like multiple times so that's like redundant right um and i think that like it often helps to start out with a brute force solution and then like logic your way to the more optimal solution because if you start out right away with trying to jump immediately to the smartest solution um it's it's much harder to immediately get that without sort of like building up the building blocks to get there you know yeah sort of over complicated ahead of time exactly yeah um and there were a bunch of things i also really liked like you worked through examples as you were talking through your solution you explained what each line of code did um and you had really on point runtime analysis and you explained how you derived the runtime analysis as well and i thought that was all really fantastic um and so i also agree about your point that like um i think maybe the reason that you might have made a mistake on line 41 was that like the variable was named current node so like that implies like current now then it's a little confusing so sometimes when you're working with really confusing code like this it helps to you know use really clear variable names and be clear on like what each line of code is doing you know but otherwise like you caught the rest of your bugs as you were coding and with your test cases as well so everything went really well thank you so much really appreciate it yeah so thank you for joining us today and thanks everybody for watching um if you have an upcoming interview good luck thanks everyone bye thanks so much for watching don't forget to hit the like and subscribe buttons below to let us know that this video is valuable for you and of course check out hundreds more videos just like this at tryexponent.com thanks for watching and good luck on your upcoming interview [Music],Spotify Software Engineer Mock Interview： Merge k Sorted Linked Lists [cN4JCxBZcM4].txt
Mock Google Coding Interview with a Meta Intern,46dZH7LDbf8,"Kind: captions Language: en bro. [groaning] Yeah, but don't worry. This is going to be fun for one of us. For me, can you like calm me calm me down before we start? I'm nervous. I haven't coded in a in a long. It's ever since I failed my last citadel interview. All right, bro. If I fail tomorrow, I will be calling you. Okay, pause. This is Frying Pan. He's a college student who recently finished an internship at Meta. And today we are doing a mock Google coding interview. The day after we conducted this, he actually had an interview at Bloomberg for a new grad position. But if you're new to the channel, I'm Neat Code. I started working at Google as a software engineer about a year ago. My channel is all about helping people prepare for coding interviews. By the way, if you're preparing for coding interviews, definitely check out neatcode.io. It's a site that I created to help you ace your next coding interview. We also have courses for algorithms and system design. And actually the question I'll be asking frying pan is from this list. Anyways, moving on with this mock interview. I'm trying to emulate how a real Google coding interview goes. So this is meant to be as realistic as possible. I'm going to give Pan a data structures and algorithms related question and I'm going to expect him to solve it. It's okay if I have to give him some hints, but he should be able to solve most of the problem by himself if he wants to get a higher rating. And either after he finishes coding or we run out of time, I'm going to do the debrief, which is basically tell him how he did, what he could have done better. I'm going to give him realistic feedback on how he can improve for next time. And I'm also going to give a binary decision on whether I would hire him or not hire him. So without further ado, let's get started. Okay. So, I'm gonna start the timer right now. [snorts] Okay. [clears throat] Okay. So, this is a question. I want you to design a class that supports these three operations. So, the first operation is inserting a value. And you can assume that there's no duplicates allowed. So, you might be given a duplicate, but you don't want to actually store the duplicate. The second thing is removing a value from this class. And where it gets interesting is I want you to be able to get a random value uh that is already inserted. And among the values that are inserted, I want it to be of equal probability. So just these three operations. Okay. Okay. Um, all right. So, let me just repeat the question back to you to make sure I understood it. [snorts] From what I understand, I have to create a class that essentially has three functions. One is to insert an element. Second one is to remove an element. And the third one is to get a random value that is currently in the class. Is that correct? Yep, that's exactly right. Nice. Are these values like integers or strings or like animals? Like are they specific something? Yeah, you can assume that they're integers. Okay. All right, great. So then let me ask you this question. Are there going to be a lot of elements we're inserting or um is it just going to be a certain amount? Uh you can assume that it's like a reasonable amount like less maybe like in the terms of millions but it's you shouldn't run into like any limitations like with memory or anything like that. Okay. So let me ask you another question. Is there going to be more insertions done or more removals done or more get randoms done? Uh you can assume that they'll be like of equal quantity like equal proportion. Okay. Thank you very much. I'm going to ask you one final question before I start coding. Can I code in Python? Sure. Okay. Here we go. So, the first thing I'm going to do is create a class. Wow, there's auto capitalization in this Google Doc. I don't know why you guys perform your interviews in Google Docs. I think it's very stupid, but All right. So, class um um [clears throat] Okay. So, let's just call this a store. Class store. And we're going to start with the constructor. Is there a way to turn off this uh auto capitalization? Sir, this is really annoying me. Just ignore it. Yeah, you can just pretend like we can ignore the capitalization. You can just assume it's Hey, try to ignore it. I'm just going to say it's not very inclusive of you cuz I have OCD and this is pissing me off. All right. So, uh constructor in it and this will be the constructor. So, here we go. What is what are the variables we need here? Right? We are inserting values and removing values. So, we need a data structure to store these things. So, let's think about what we actually can use for this. We can either use an array. So if we use an array um inserting removing will be um okay so it will have to will be all of one on average but um since we're inserting a lot of elements um okay we have to keep growing in size and it might be useful for the get random since we have an index. Okay, let me just think about this for uh 5 seconds. Okay. So if we use an array to insert these values and we don't want duplicates. So let's say we just use an array and we insert values. Um h removing a value would be all event since we have to find the actual value. So let's say we use a hashmap to insert these values. we can uh make sure that there are no duplicates and we can make sure that inserting and removing is on average um very fast or of one. Now that sounds good to me. Mhm. Okay. The third thing we have to consider is we need to get a random value out of everything that is inserted. um hm how to get a random value with equal probability. Yeah, when it comes to getting random, I'll actually help you out here and just let you know that you can assume that there is a method, let's call it random.choice, choice I think in Python and it takes some list of values and it'll return you a random number with equal probability from that list. I actually already knew that but thank you very much for the reminder. So let me just start by initializing a hashmap map equals to uh inserting values. Uh okay I'm this. So the next function will be insert def uh insert and for the parameter it will just be a value right we're passing one value to this function okay so [clears throat] let's see um I think we can just insert it directly like this um value inside of it I think this can actually just be a that um since inserting a value removing. Okay. So there there's nothing um for the input. Is it just one value or is this uh something else during the insertion? Yeah, you can just assume that it's an integer. Okay. Okay. Then I think what we can just do is um add this value to the uh set and okay and then for the remove can just remove value from that remove value. So these will be very quick operation. um no duplicates. I think this is fine since it's a set. So if there's already one, it will just replace it or not put it in. Um and then for the get random uh get a value that is already okay. So if there's a function that you can just get something from a list randomly, I guess the easiest way is to just convert this set into a list and use this function on it. Okay, so we can just do return um yeah return um [clears throat] random. choice list self.map and yeah let me put this uh here since these are class function. Okay. Um [clears throat] so we can al also add some uh checks for uh this set like to see if it's like empty or not before removing um or to see if this map exists but I think that's fine since by initializing this class uh this map will exist. So yeah this will be O of one insertion O of one remove and um this will be O of N for the get random and yeah yeah that's correct. So this definitely works. Is it possible to get the get random function to be a bit more efficient? Okay. So uh this random choice is O of N correct like it it has to iterate through the entire list to uh give an answer. Yeah. Well let's assume that the random is actually constant time. So okay where your function is becoming a linear time is converting the entire set to a list. I see I see. Okay. [snorts] Okay. All right. Okay. So let me think about this. Um since the conversion is cannot be avoided if we use a set I'm assuming uh for this to store these values we probably have to use an array. So [clears throat] um the problem with using an array is the [snorts] removal will be uh not efficient anymore. Is is that an issue or do we want all these functions to be O of one? Is that what we want? Yeah, that's a good point because if we do it the way you kind of proposed, we can get the get random to be more efficient, but remove will then be linear time. So, we don't really improve anything assuming that each of these is called like an equal amount of times, which you clarified. So, yeah, you're on the right track. I is it possible that we can get all three of these to be constant time? Okay. Let's see. Okay. So, I think we probably have to use a combination of uh data structure here. So, let's say we have an array where we store these values and um yeah, we insert and we remove values from there. Um then let's say we have a hashmap that stores the index of each value. Then um when we remove we can just remove it from the hashmap and take a note there. And then we know that it's not in the array anymore even though it's like technically still there. um then we can fix the problem of removal being uh slower. So then removal and insertion will will both be on average of one. But then for the get random there will be there will be integers in the list that are not supposed to be in there. Okay. So h how do we make sure that those integers are not taken into account? Um okay, what if every time we have an a value we want to remove and we know where it is in the array, right? So let's say we switch the place of this element to the beginning of the array and or to the first element that is still supposed to be inside this array. So then we can essentially segregate segregate separate all the values that are technically not supposed to be in the array and all the values that are supposed to be in the in the array. So once we have all of this separated, um, what can we do then? Okay, so I'm thinking if we have all of this separated, right, we know where the separation is. We can probably know um the last element that is not supposed to be in this array. From there until the end, we can Oh. Oh, yes. So we can do from there till the end uh use the random choice on on those. But then we still have to slice the array. So that's still kind of O of N. It's like a bit better. Um does that make sense? Yeah, I think you're definitely on the right track. I guess I have a question. So you said earlier that the problem is we can't remove a value from an array in constant time, right? Yeah. Why is that the case? Because uh it could be in but on average it will not be constant time since if it's in the middle of the array, we have to move all the elements at the end um and like push them back. Yeah, that's true. Is there any case where removing from an array actually is constant time? Oh, if it's at the end of the array, it'll be constant. So, if that's the case, wait, what does that tell me? Okay. So if Okay. So if we do that and at every time we remove something um we switch it with the end of the array and then we remove it. That will be O of one. And then we can just use the random choice on the original list because they won't have all the values. Okay. Okay, I will start coding now. Okay, sounds good. [clears throat] Okay. All right. So, uh Okay. So, the first thing is we'll initialize a array self dot um we'll call this value. [clears throat] Okay, we'll call this values. and it's going to be an array and we're also going to use a hashmap to store the index of each value where each value is. Okay. So now for let's let's go for insertion. How will insertion work here? So I think the first thing we need to do is check if it's already in there. So if the value that we want to insert is in self.m mapap then we want to uh return since we don't want any duplicates right so um is this the correct behavior we want so if there's a duplicate we just do not [music] insert the new value yeah that works okay so once we have this Um um I think we can just perform the insertion. So self dot uh values we can we can put append value. Now how do we know what index this is? Because we have to put this in a map. Um so the value of this will be equal to the index. So this index will be uh I think the length of this array [snorts] since it's the last element. So length of self do values minus one. Perfect. I think this is correct for now. Value in self.map if it's already in there we return. Otherwise, we append it to the values array and we store at what index this value is. Okay. Okay. So now let's go to the remove function. The remove function um we first want to check if it's in the map at all. Right? So if value is in self.map then um well if it's if it's not in the SF.m map we can simply uh return. Okay. Now if it is if it is in that means it's um it's an accurate value that's also in the array. Okay. And then we want to remove that. So um we can find at which index this value is by using the map. So self do value uh self.m map value to get the index of where this value is inside of the actual array. And then uh here is where we need to perform the [snorts] swapping. Okay. Um okay. [clears throat] So let me think about this. How do we perform the swap? H okay. So I think we just move it to the last element. Um and to do this we can simply um do um the last let's save the last element. So um last value is going to equal to self do values minus one and then um we can put this new value at that place. self do. values um value equals to um values minus one. Okay. [clears throat] And we want to put this one back. So uh self.m map um last value is going to equal to index. [sighs] Okay. Let me just make sure the swapping makes sense. So I'm getting the last element from this array, saving it, and then replacing Um, and then adding this new value. Uh, I need to add it to the last the last index. So, I'm adding this new Wait a second value. Okay. So, now I'm adding this new value or no, we're removing this value. So yeah, I'm I'm adding the a value that I want to remove to the last index of the values and then um I'm putting the previous last value at um the index of the other element I'm trying to remove. Okay. And then at the very end of this we can then remove um said value we want to remove. All right. So, uh I think we can use use delete. H how to remove an element from I guess we can just use I don't know if delete is the correct keyword, but I'll just set it to uh none for now. Yeah, I think delete is fine. Delete is fine. Okay. Delete self values minus one. So, I delete the last value from the array. Okay. And inside of the get random uh function, we can just simply do random choice um self values. Does this make sense? Yeah, this makes sense. So, a quick correction actually. I said it was delete, but I thought uh we were talking about the hashmap, but for the list itself, uh you can just use pop. Okay. Yeah. Great. true. Yeah. Okay. And um Okay. So, I'm missing something here is we need to also update the map. Um so, in order to update the map, we're going to do uh delete self.m map and uh value. And this deletes it from the map. Okay. So let me just make sure in the insertion we're appending to the values and we're also updating the map and in the remove we're also updating the values array and also updating the map. Um we perform the swapping. Oh uh do you want to walk through a couple like test cases? Yeah. Yeah for sure. Okay. [clears throat] Um okay. So let's say we insert um um three uh four five five. [snorts] Okay, let's just say we insert three four and then uh we want to remove three and let's say we insert also five and then we remove three and then we uh get random. Okay. So then obviously we we we first we initialize the class and then um let me write down self values is this self.m map is okay so to keep track of the values first we insert three now and in the insertion a value in self map is not in the map it's going to append to the values array. So we have three and then it's going to put it in the map. So in the map we're going to have three with index index zero. Okay. After this we're going to insert four. Insert four again. Actually the first four um it's going to be the same thing. So append value four to the value array and put it in the map. So four with index length of self values it's 2 minus one is one. So here we go. Then we insert four again. It's already in it. We just return. Then we insert five. So same thing. It's going to append five to this. And um self five is going to be uh two value of two. Okay. And at this point we want to delete three. Right. So going into the remove um function we can see that three is inside of it. So now we get the index of three which is x = to zero and then the last value is equal to five equal to five and self do values minus one is going to equal to the value. So here we're going to update five to um value we want to delete which is three. And then um self.map last value equals to um whoa hold on um equals value. Okay. So I think I'm missing something here. So we need to also reput the first element that we deleted back inside. So self values at index is going to equal to um last value. Right? So um this index is zero and we're going to replace three with uh five which is the last values value. Okay. At this point, um, we're updating the map. So, self.map last value, which is five. We're updating the index back to zero. And then, uh, we pop from the last, uh, array. So, it's only 54 now. And we also delete, uh, three from the map. Okay. And at this point, uh, we get the we get something random. And it's gonna get something random from five or four. There we go. Yeah. Perfect. We got it. Yeah. [laughter] That was a good catch. So, I have a question. A couple of questions. So, would this remove? Yeah, actually. Uh, no. I mean, it looks good. I guess I my other question is so this solution works perfectly if we don't allow any duplicates but what would happen if we did allow duplicates like we could have multiple threes multiple fours and in that case uh the probability would still be the same actually like we would still want the you know the random to be proportional to how many times each value has been inserted so we don't have to change the get random, but how would you change the rest of this code to allow for duplicate values? Okay, so in that if if that's a scenario, that means uh the four here that we implement, so there's going to be two fours um in the array, correct? In this example I have down here. Yep. Okay. So that wouldn't work with the current one because uh in the hashmap I can only have I I cannot have duplicates. So in this case I think uh what comes to mind is instead of uh associating each value with just one value one index I can put an array here and um instead of counting okay so if I use an array I can store multiple indices So if I have a four, I can I I can have a four at index one. I can have a four at another index. And by having that um yeah we then we just have to u update the so in that case the remove can just uh delete any of these fours right it can be the first four four or the second four the third four it doesn't really matter and I think that's that's pretty much it I can just replace the one with an array way to uh keep track of the duplicates. So yeah, that's exactly correct. Yeah. So and yeah, in the insertion I would obviously check if it's already in the self map, I would append to the array. Um does that make sense? That sounds good. Hey. Yeah, we can code that up. Oh, okay. We code that up. All right. All right. [clears throat] Thought we were just talking. All right. All right. So if that's the case, um, in the insertion, we're going to start here. Uh, if value is in self map return. So obviously we're going to change this. Um, okay. So instead of using a um initializing like this here, I'm going to use collections.default thick. Uh, and I'm going to put a list in here so I can just append directly to an empty list for every value. So if the value is already in the self map, um, I'm just going to do self map value.append uh, [groaning] length of self. um minus one and also obviously append this to the values array. Boom. Okay. And delta. Okay. So maybe this is the only thing. Del map valalues. Um okay. So actually we don't even need this. Um, we can just do this. So, we're just going to directly um append it to a value in the map. If it doesn't exist, it's going to be an empty list. And this is going to be the first element associated with it. If it does exist, it's well, it's going to be the same thing and append it to the value array. Okay, this is this works for the insert. [snorts] Now for the removal, if the value is not in self map um return that's that's fine. Uh we have to change something regarding this swapping because now what we're returning is um an array and self map do value. Okay, so we're just going to return the first index to and we're going to delete this first index. So the index is going to be um the first index of this value whether it's duplicate or not. Okay. So then um this is fine will all work. We just have to change the the map. So the map last value equals index. We're going to do append instead of equal. Um yeah. Okay. And cell values.pop delete self. Okay. So in the delete here we have to change it. So self do map um value. This is going to be an array. We don't want to delete this entire array. So what we need to do is delete a the specific index inside of this array. And something we can do to make this better is use a set instead of a list. So I'll just use a set here. Um and we're going to since order the order doesn't matter here. I'll just use a set and it'll be faster for insertion and deletes. Uh so self do values append. So we're going to do add and here we're going to do add and self.m mapap dot value we're going to remove this index. Remove index. Okay. Um, okay. All right. [sighs] So, I think this works. Uh, do you want me to run this through an example again? Uh, sure. Yeah, let's go ahead and do the same example that you Perfect. Okay. All right. So, let's start over. So self values uh we do an insertion. We're going to go quicker here. Um we add um uh into the map first. So the map will have value three with a set of um it'll be zero for its index. And then in the values array we're going to just append three. So no problem. And then we're going to do it the same for four. So four is going to be uh like this. And then after this uh we're going to add another four. So um it's going to go self.map value add to this. So or is going to add um two here. Okay. Actually I have to do this append before adding it to map so that the length is accurate. Okay. So now that we have uh everything in the values array and the map um yeah we have the duplicates and then we add five uh five is going to be here and um five is going to okay all right perfect and okay instead of deleting three we're going to delete four here to see how it works for because deleting three will be I think pretty trivial so deleting four will the one that's uh has two that has a duplicate. Um okay so if value is not in self it is in so index is equal to self.m map value zero. Okay so zero here um I cannot use zero here. How to get the first element? How do I get one element out of a set? Um, yeah, maybe I do need to use a list. I think we can just assume that there is a way to remove it cuz I think otherwise I got it. I got it sir. I got it. We can use iterator parenthesis.net next to get the first element of the set. Now, yeah, that's great. Yes, bet you didn't know that. Now, we're going to do swapping. Okay, so uh index is going to equal to the first element, which is one. Um, last underscore value is going to be equal to the last value of this array, [sighs and gasps] which is five. At this point, we're going to do self.value index, which is one equals to last value. So, self.values index is uh the first four is going to equal to five. Boom. And then self.map last value um last value is is five. So, this one we're going to add uh this index. Uhhuh. So, we have to add f uh one here. But we need to delete the previous one. So we also need to do self self.m map class value remove um remove the last length of self values minus one. So yeah so this is three. So we remove three. Okay. And then uh we pop from the value. So we pop wait self. values index which is three. Okay. I I don't think I did this line. So self.values index which would index is three is one. Wait. Okay. [sighs] Uh I think there's a problem here. So index here is one. Self values last element is value. Okay. Okay. Okay. Okay. I forgot to do this. So five is going to be equal to four here at the at the end. So then when once we pop we're going to pop four from this. And then we're going to remove um this value which is four. We removed. We're going to remove the index. The index which was one here. So, we're going to remove one from this and we're done. Please tell me there's no more followups. [laughter] Yeah. Uh, we have like four minutes left, but I think this code looks good. Yes. Uh, do you have anything [applause] else you wanted to change? [&nbsp;__&nbsp;] no. No, I'm kidding. But I think Let me add another followup. Let me ask you a question. Is this code thread safe? Uh probably not correct. In order to make this code thread safe, we need to add locks for the insert and the remove and the get random. And that will be all. Thank you very much. Did I get the job? Yeah. So, we finished with four minutes remaining. So, yeah, let's do the debrief now. Okay. Uh, I wasn't taking notes actually. Usually in like a real interview, your interviewer will take notes. So, first, like I gave pan the question. It was really open-ended. I just said like insert a value, remove a value, and get a random value. And he clarified that these are like what are we inserting? and I said numbers like integers specifically that was good by him. I think he could have done a little bit u I forgot what exactly his clarifying questions were. I think it could have been like slightly better uh talking about like the edge cases of like what if we don't have any values that we can remove. Well, he handled that in his code. But what about if we don't have any values that we can get a random value from? uh the way we coded it, we assumed that there's always going to be some values inserted, which is the case, but uh that was more of like an assumption that he made, but he didn't like like specifically clarify that. But I think it worked out. uh as he was coding he when he finished he talked about like the time complexity and you know without without being prompted to like before he even coded he was talking about ways to make it more efficient. I think that's good because you could easily go down like the wrong track with these problems and if you go too deep without asking any clarifying questions you might have to like restart your entire solution which will waste a lot of time. He didn't have to do that because well like this problem you either use a list or a hashmap so you can't really mess up but you know it could happen with other problems. So running through like the test case he did really good I think on just like keeping track of everything just like explicitly writing it down. When I say like do a test case like in real interviews people will actually mess it up a lot. Like sometimes people won't write any notes like as they're running through a test case and like they just lose track of what they're doing and sometimes I'll even lose track like I don't even know what they're like saying anymore. So I think Pan did a good job of like making it pretty obvious to me what he was thinking about the entire time like what was going well and like what the time complexity was, what data structures he was planning on using like just everything. So overall, and like you got the correct solution for the first question and the follow-up, I guess you needed like a few hints, but the fact that like the solution is correct. I'll give like a binary decision of whether I would like lean towards no higher or higher. And I would say for this problem, I would definitely give you a higher. So let's go. We passed. I guess Citadel thought otherwise. Wow, you had to add it in there. What the [&nbsp;__&nbsp;] Soon. Sorry. What the [&nbsp;__&nbsp;] Okay, I have a question for you. I have a question for you. In your real interviews, do you talk the same [laughter] way? No, of course not, bro. [clears throat] I Wait, what's wrong with how I talked? No, I mean like nothing. Nothing. It was good. Now it's my turn to interview you, Nicole. I have a hard DP question for you. Okay, let's go. Okay, that's going to be on next time. It's coin change. All right, it'll be next time. Bro, you should stream and we can stream together. Yeah, this was fun. Honestly, just like reading chat at the same time. I was just reading chat like during the entire interview and I would like glance over and just see if you had [laughter] any",Mock Google Coding Interview with a Meta Intern [46dZH7LDbf8].txt
How to solve a Google coding interview question,Ti5vfu9arXQ,Kind: captions Language: en hi I'm Aus a technical recruiter here at Google in this video we'll show two software engineers at Google working through a mock technical interview question please note that this example is not a question you'll be asked exactly however it represents the type of questions we like to ask our candidates one that allows you to stay your assumptions improve your solution and is ultimately open-ended enough to show us how you think if you're interested in seeing an example of solving a system design question or learning more about our hiring process visit the videos Linked In the description below on to the mock interview hello my name is Sammy I'm a research scientist at Google research and today I'll be playing the role of the candidate and I'm Juliana I'm a software engineer at YouTube and I'll be playing the role of the interviewer just as a reminder you won't have access to compiler or IDE during your interview so practice writing code with Google Docs try to do it at home write code make sure your code is tested do this process before you come to the interview and don't worry about small synx errors like which substring to use for a given method just pick one like start end or start length and let your interviewer know okay let's get started okay so Sammy here's my technical question for you a farmer wants to farm their land with the maximum area where good land is present the land is represented as a matrix with ones and zeros where ones mean good land and zeros mean bad land the farmer only wants to farm in a square of good land with the maximum area please help the farmer to find a maximum area of the land they can Farm in good land I'll past the question and that includes an example as well for you awesome may I take a moment to read and then ask you clarifications of course thank you awesome so my first question must it be a square the area they want to farm or could it be a rectangle for this problem we only want it to be returning a square awesome okay thank you as a reminder it's important to get clarity whenever possible many questions will be deliberately open-ended because we're looking to see how you engage with a problem and your primary method for solving it be sure to talk through your thought process and feel free to ask specific questions if you need clarification and um I can think of like the naive solution but probably I shouldn't do this but I'll just run it by you okay I can Loop over every position and for every position I can basically start from that moment onwards go left right and count however many ones I can find in in like the a rectangle or a square sorry but that would be if let's say the dimensions of the square is like n byn that would be at best n to the four which is not ideal and I assume by posing this question you want to find an efficient solution yes this was a good example of explaining your thoughts remember we want to understand how you think so it's always good to explain your thought process and decision making throughout the interview not only evaluating your technical ability but also how to solve your problems be sure to explicitly State and check your assumptions with the interviewer to ensure they are reasonable I'm wondering if you can just visualize what maybe this Brute Force approach would look like maybe using the example sure okay so the Brute Force if I want to visualize it so I just pasted the example and I'm going to go over every index IJ index and I helped the first this is the second this is the third Etc uh let's say we get here in this iteration so I is becoming let's say two and J is becoming one in this position the row and column so from from this point as every point that we go to we start another double for Loop going to the right and bottom so here I go one step to the right there is a one so I continue and then I go to the bottom there is a one and I continue and then I go to the right of it there's a one I continue uh I wonder if that makes sense so first we start saying okay he when we get to this point we we have we know that we can do a one by one then we ask can we do a 2 by two and if the answer to answer that we have to complete the 2 by two triangle so we have to look in this vicinity so to speak yes then we say okay now yes I know I can do a 2 x two starting from this position can we can I do a 3X3 and to answer that we have to go on this like wrapper like I'm going to select them one by one because it's hard to S otherwise and I then I select those uh so we like extend the boundary by one column on one row check that there're all ones there and then we keep track of the maximum so if we arrived at three here then I memorize that three is the best so far and then until I Loop over all the indices possible maybe I'll update my three to something else and it'll return wherever number has been kept but as we already said this is not optimal but it will do the job I think that even though this may be a Brute Force solution it would be the right approach in checking the nearby values and having that inform how large the square could be awesome and I guess do you want me to program this for solution or am I going to penalize it should I just think about something about we can just move on to maybe what you would consider a more optimal solution sure awesome okay so these kinds of pro problems uh I feel like I can solve them in two other different ways H the first one would be recursive so here the recursion can say um let's let's ignore the zeros because as soon as I find a zero we can just return from this point you can't have a square but let's say we get to this point like oh yes there's a one so I can make a 1 by one uh then we can ask the surroundings can we make more than one by one and then if if if I can ask the square next to me actually let me think about it okay if if if this is a one the right of it is a one the bottom of it is a one we can ask this this that I'm highlighting how big of a square can you make it actually no I think you're on the right track that you're checking the right uh below and diagonal values but because there is a zero here does that mean it could be a valid Square zero is invalid right yes yes that that would be the case so so based on that what can you infer that if that you're at that one position at the um that index yeah if I'm the index what can you infer as the maximum Square this index uh it is a one because we can see the diagonal is already a zero yes yes that's correct but you then know that the neighboring values are also ones so there is a possibility that those could have valid squares that are greater than one correct yes I mean in this specific case because the diagonal is zero that means this next to this one below it is a zero unless we're coming from above true right I guess the one below it uh actually neither of those but you could potentially have as you're saying a recursive algorithm how would that look then MH so the recursive algorithm I'm I'm trying to think out loud as as I'm as I'm describing the solution so basically when we see a one here we can we can we can ask can this be part of a bigger rectangle and uh recursively how would that look like we have to ask the neighbors how much how many ones they have conectiv continuously mhm so that could be saying that okay there's a one here um then we can invoke a recursive call that says how many how many ones are starting at the right of me making a square so if if I wish I can highlight but let's let's imagine me I'm going to bold this I'm going to bold this that marks the end and the beginning of of a square so when I'm at this one right here I asked the square I asked right of me how big of a square can you be and uh if let's say this whole area had ones even though it doesn't if it had all ones the right of me should say oh I can do a 3X3 and I'm I'm I'm going to try to break this down into maybe one step at a time so when I ask this one how many ones do you have how how big of a square can you form it could ask the one right of it how many can you form it can ask the the bottom of it how can many can you form yes and and then if how whichever so whichever Returns the minimum I will take that and I'll add one to it trying to think if this will always be correct so if this one said I can do a a two 2 by two let's say it's it clearly can do a 2 by two I'm going to change your input by a little bit if that's okay so which which means this would have been one this would have been a one okay and this the one that I'm highlighting is asking the one right of it how big can you can you be your Square can be this will say oh I can do a two then it ask the bottom of it how big of a square can you do and this particular case is going to say three uh because I can see the ones like here this one I think that and this one are making a square ah I see so you would compute it like top down so that one that you've highlighted um in the in 2 two index or 2 two coordinates would have a contain a three value because it can form that 3x3 square right exactly got it yes that makes sense and uh let me see if if taking the minimum is uh sufficient so to speak so this one can create a 3X3 yes the one right of it can create a 2 by two or I guess now the example is so corrupted because I kept changing things uh let's see actually uh this one yes so this one that maybe I should color uh so let me color this to red the red one will say I can do a 2 x two starting from this coordinate yes the the blue one or the one that will become blue we'll say I can do a 3X3 starting at this coordinate yep now how much can this one create the one I'm highlighting it would still be the minimum I'm thinking right because you can do more than 3x3 okay so now now we can think about the base cases of the recursion so to speak yes so the base case if we had a zero then we can't do we return a zero yes if we had a one then we ask the right and the bottom to do the recursion we invoke them and we return their minimum yes I'm trying to think at which case do we in which case do we grow I'm thinking we can grow let me think so if this if the red one hypothetically said I could do a 3X3 I'm just thinking um and the bottom one can say I can do a 3X3 okay um I I need to think that there there has to be we can grow the ones you know we have to return a five or something eventually so if the right of me can say I can do a 3X3 which you know so maybe I can hack the numbers again just for the sake of example it can say I can do a 3X3 uh actually this is still a 2 x two okay I have to do this as a one so the red the red one can now do a 3X3 the blue one can also do 3x3 only 3x3 exactly um then this one is so far is going to say three is the number however if this was a one right here it will be four then it will be four but let let me just like so that would mean the diagonal number would also be three to which case because you have a one in that first field the at the 01 coordinates M um what could that say if all of the three values down diagonal and to your right are all three and this is a one what could that be makes sense okay so if all the values are three then I should say I can do four exactly Mak sense okay okay so I think I think I'm able to write it recursively of course the recursion is not the most optimal because it has to retry something multiple times we can always add a memorization memory element to it this way each unique invocation will only happens only once which will make this be at most quadratic we we will invoke it at most n Square times then but usually for anything that you can do with memorization there ought to be a dynamic programming solution where you can do Bottoms Up you want me to program the recursive uh memorization lazy version or should I strive for the most efficient dynamic programming version I'm thinking that I want to first see your thinking for the bottom up the dynamic programming solution and then we can go ahead and code it I just want to see what your thinking would be for how bottom up would look sure okay you kind of gave me a hint already by saying check the diagonal if it also can do a 3X3 uh so in that regard maybe I can have I can this is the input we're highlighting right now we can start with the with the dynamic programming array with this that has the same exact size but it's initialized to zero everywhere y then at any moment that I want to compute an entry I want to populate an entry in this DP Matrix that starts at all zeros I'll be looking at the the the same position of the of the input and also the surrounding positions of the input and potentially the surrounding positions of the dynamic programming array the DP array and populated incrementally as such and so your DP array would contain which what values exactly okay so at every at at every entry in the input if the entry in the input is zero then we should write zero in the dynamic programming array if the entry is one uh then we need to basically look at the surrounding positions as you said like the top position just top of me just left of me just diagonal left of me in the dynamic programming array and we should take the minimum but if they all agree to be like the same value I'll just increment by one in the DP array and uh the final return of this whole program is the maximum entry in the DP array yeah does that sound correct that sounds correct um I do want to highlight that you will be then capturing the height of the square instead of the area in this array mm and if that's fine too if that's the direction you want to go in capturing the height okay because it is a square so it is a square I see yeah that's right yes okay um should I start programming the dynamic solution and I can explain it as a program it if that's okay that sounds great let's do it okay so programming python into a document so maybe I can choose consolas as as a font and I can say def U largest square and it takes input as a b array I'm going to say B array is that fine do you want it to be typed or no typed as in like know this the typing of python should I do something like this mp. ndr or at least say it's a list of list of int you want these types it will be a list of it will be a 2d array of inss yeah that's perfect awesome so and then the answer is just an INT which is the maximum area exactly okay so first I'm going to say my DP array is equal to an error of all zeros I guess I can I want to capture first n uh which is the the length of the bin array so it could be a 5x5 10 x 10 square Etc it's End by end so we want to make an all zero I'm going to do this okay so now after this line DP is just an N byn array with all zeros oh something that I wanted to point out here is that it's possible that it's a m by n the width and the height do not not agree uh yes for the input array good to know but your output array or your output area should be a Square thank you for making this clarification okay so then I will do this as my n * m and now I can say something like this yep so let me just make sure yes I'm consistent in my indexing so to speak uh that if an index I exists in DP then it must also exist in bin array yep awesome okay so my DP starts at all zero now we you're going to do the double for Loop that we mentioned so for I in range and mhm forj and range M and here at every Square we're going to write the maximum that we could do yes scroll down so let me think uh first if if the entry had a zero f yeah bin array of I J is zero then and the DP will have a zero in it yeah so in that case I will just because the DP was initialized at zero I can just continue I can skip to the next iteration if I'm allowed to use continue yeah yeah of course awesome okay so the then at any entry that's not a zero we should look up the left and the top and the diagonal and we'll see their values so maybe I can say say left value is equal to right value for now I'll set them later to the diagonal value all to zero and I'll set them conditionally why because I don't want to I want to skip the boundary conditions so if the left of me if I is uh greater than zero that means I'm not at the boundary that means the left could be something that's not zero so now we set the left to DP of IUS one J uh yep and I want to do the same thing similar thing to the right one otherwise they will stay at zero um quick question is it possible to handle the boundaries before you enter this scope yes uh yes I'm sure so we could copy the boundaries from the input ver team to the DP and then our Loop could be starting from one instead of from zeros um I'm thinking more so that if you are in the zero index of the row or the column if there's a handling you could do before you enter this scope of setting the left and right diagonal indices so you're saying like before we enter these Loops we should handle the borders maybe that's what I'm hearing maybe yeah I think it's possible to do it within the loop if you'd like we could um or let me know if that doesn't sound right we we could do it so you are saying that perhaps instead of having these if statements inside the for loop I could do something before then I no longer need these if statements you could do it outside of the for Loop you could do within the for Loop either way I see okay so yes I could do that I mean there are many ways to do it so uh I I want to think that yes okay so how about I want wonder if if it will complain okay so mathematically speaking I can do this left let me let me know what you think about this so what if I set it to that and then I just multiply by a Boolean expression uh I is greater than zero so here what I'm trying to do is to say h the I greater than zero this booing condition will only be valid will only say one if I'm not I'm not at the boundary if I'm at the boundary then I can say your left is zero is that yeah that's possible that's possible but then what if the value is one then the maximum Square could still be one even in the row and column like the edges right so I still so yes here like this right and left and dag so far they're just for reading I still haven't inserted anything into the DP uh my plan is to insert in a moment like perhaps right now awesome okay okay so if if uh if I is greater than zero and J is greater than zero and now I can read my diagonal diag is equal to I'm going to copy the line four and just add a minus one and now I want to write the DP at this moment right here so H we just like we're brainstorming if they're all if they're all set then I'll read the minimum of the three and and increment by one if they're not set then I'll just read the minimum yes uh and what would be the deciding factor for that whether the yeah what would be the deciding factor of that the so to increment by one yes a basically the the array right here the array entry should have a non zero got it we increment by one and that's the first if statement in the nested for Loop that if we are at zero then we just skip that entry we keep it in the DP as zero okay so if the code flow until this point then here I know that we it's a non-zero point and the top the left and the diagonal have some numbers and using those numbers the to the top left or right some of them could be zeros uh the top left diagonal some of them could be zeros if they are all set that means I should take the minimum plus one okay right Mak sense right that makes sense awesome if left is greater than zero and right is greater than zero and diag is greater than zero then I will set the entry right here DP i j to the minimum of those left right I think I should put it in Array syntax wise I forgot but I can try that h plus one okay let me think is there wait sorry quick question is there a reason why we need to check the that all the values are greater than zero if we are taking the minimum here if we've already checked that the it's not a zero value do we need to actually check that we don't need to you are correct yes so this if statement is IR relevant because if any of them is zero then the minimum will also be a zero and the fin answer will be a one which is exactly what we need you're right this estatement is not needed if anything it might make a bug okay no that's perfect yep awesome so we still don't have the final answer the final answer is keeping track of what was the maximum of course I can stay within the same computational complexity and I can just say return the max over all of this y so return I guess I'm going to say row Y is Max is equal to Max Row for row N DP and then I can return the Max of rowwise Max So rowwise Max in this line uh basically it becomes an N numbers H each number is the maximum in that row and then return the maximum of those so we have the ma we invoking the max function once in this four Loop and once again on the list the final list um is there a way to potentially get the maximum or track the maximum within your for Loop yes there is a way um I can do that awesome thank you so I can start as the max so max num as1 in here and every time I update I basically read off the Max uh so I can say Max num is equal to the max of the previous Max num comma DP i j uh and then return at the end and of course there is some you know with every there is ways to optimize it um like for example specifically here we are storing in an index of an array we're reading again the same index I could have stored this as a variable Z or temporary variable but I'm hoping the compiler will take care of that for me we make it optimal definitely um yeah this solution looks good to me awesome and I like the fact that you kept correcting me and gearing me towards the better solution you are a good interview it was you you were always on the right track thank you you I hope this gives you a better understanding of what it's like to answer technical interview questions at Google as a reminder be sure to explain your thoughts get clarity when possible think through how to improve your answers and practice ahead of time thanks for watching and good luck in your interview [Music],How to solve a Google coding interview question [Ti5vfu9arXQ].txt
Coding Mock Interview - Move All Zeros To End Of Array (with Google SWE),56QSCo2gBfA,Kind: captions Language: en given an integer array nums move all of the zeros to the end of it while maintaining the relative order of the non-zero [Music] elements hi everyone we're here today with Simon for another software engineering boach interview thanks so much for being here with us today Simon can you quickly introduce yourself yeah uh hi folks uh I'm Simon Ean and I'm a software engineer at Google uh in the past I've also built systems at Spotify and Bloomberg and interned at Etsy and for square and excited to be back for another mock awesome yeah I imagine you've had to do a lot of interviews then so I'm excited to see you use some of that experience here today um all right so let's get right into our question for today given an integer array nums move all of the zeros to the end of it while maintaining the relative order of the non-zero elements and before we get started be sure to click the link in the description to check out exponent software engineering interview course Acer interview with library of interview questions in-depth mock interviews on coding and system design and a peer-to-peer mock interview tool to practice yourself uh so I see here that we have an example input and its expected output we've sort of moved all the zeros to the end here yep um I guess I have a few questions uh can I use extra space for this problem as then can I return a new array for the solution that's a good question uh we would prefer if you could do this in place yeah I mean that's fair uh I think you know if we could use extra space my my high level thought here is that maybe we could go through the array and then fill our result array with the non zero integers first you know in order um and then we can just fill the rest with zeros until we kind of match the sizes but yeah um I I hear you right that sounds like a pretty good solution but unfortunately we've got to assume we don't have that extra storage sure yeah that makes sense um so another question I had uh will the array have duplicate values uh yeah you can assume it might have dupli at values sure yeah I mean I don't I don't think it should affect the ultimate algorithm but I think it's you know good to keep in mind potentially for examples or something like that test cases um so overall I think that one approach that could work is you know we go through the array that we're given um you know remove all the zeros as we go and then just add them back at the end I think that could potentially work um okay sure so what would the time complexity of that approach be yeah I think that's ultimately the problem you know removing an element from an array as an O of n operation uh it requires shifting over the remaining elements to fill the Gap so in the worst case for the overall algorithm we'd potentially be removing something about like n elements so I guess that would be o of n^2 overall mhm yeah yeah so I'm wondering if you can do better here yeah yeah we definitely can um I guess this idea is a little bit out there but I suppose we could sort the array um which would technically be faster than quadratic time it would be all of n log n um the only thing here is that we'd probably just need a custom comparator for the Sorting uh something like you know zeros are weighted as infinity or something like that so they get pushed to the end uh and all nonzeros are kind of I guess weighted the same um I think python which I'm going to use I think it also guarantees stable ordering for its sorting so and that's necessary for our problem but I think something like that could work too right yeah that's a good thing to mention that the stable ordering matters here in order to keep the non-zero elements in the same order right so um that sounds like it would work actually it's not so far out there uh what are some of the downsides of this approach yeah I mean I suppose that one down downside here is that it's kind of like a cute solution uh to this you know very particular problem uh it's it's not a very extensible solution if say you know the problem parameters were to change uh but I think that a bigger downside is that it actually might still be too inefficient my my gut says that there's probably like a linear you know oen solution here okay so what might that look like yeah I was thinking that one common pattern I could try applying here is something like a two-pointer approach uh so ultimately we want to move all the zeros over to the end uh or I guess perhaps a better way of thinking about it is you know we want to move all the nonzeros to the front of the array um so I suppose that we could so we could iterate over the array while also keeping track of where to put that sort of next nonzero value uh you know the earliest position that needs to be filled um I think that would ultimately end up being o of end time I do need to try it against an example though because I'm I'm not fully sure how many pieces of data to keep track of and you know if I'll actually get all the zeros at the end so so let's maybe uh try it against an example okay yeah CU I was just about to ask where the pointers are pointing right uh so so let's start with maybe a longer example than this one let me just kind of try an example where we have zeros kind of everywhere um so let's do Z four say another zero two 3 let add another zero for measure one Z okay um so if I have this input well ultimately want to get is 4 2 3 1 and then four four zeros yeah I think that makes sense um okay so so let's let's start kind of keeping track of our data so if we have something like this let's sort of set ourselves up with a you know left and right pointer and then kind of see where that takes us so if we want to start shifting all of the nonzero elements to the left we'll start here um you know what's the ultimate rule that we're looking for um if the value that we're at is not a zero we kind of have to shift it to the last existing position so this is a zero so we kind of do nothing so let's say for argument sake you know and this iteration our right pointer moves forward uh then we check what's happening at the right pointer this is a non zero so we fill that left pointer with whatever's at the right pointer so that four gets put over there okay that makes sense yeah yeah so just to make sure I'm understanding what you're doing so the left pointer is always going to point to where you want to store all the non the end of where you're storing all the nonzero elements and the right pointer just points to where you're currently iterating through the array yeah exactly like we're sort of moving that right pointer forward one at a time and then the left pointer should technically only shift when we're moving something there um so like in this case we took what was at the zeroth the first index and we moved it to what was in the first index the zeroth index okay got it right so so at this stage you know we move forward the right pointer like we did uh we also have to move the the left pointer actually so these both shift forward um we check what's here it's a zero so we keep iterating forward we check what's here it's a two so we want to put that where the left point is so that becomes a two um then we shift both of them uh because we just filled in uh what was at that left pointer again we have a nonzero value so this becomes a three so these both shift um this is a zero so we keep going forward uh at this point we have a one so we fill that we have over here a zero so we don't fill that and then I guess the right pointer goes beyond the limit of the array so we're kind of done um we're not technically done because I see now and this is kind of what was on my mind that we still need to fill the zeros at the end so I guess one last step after we do that iteration is we just kind of continue that left pointer forward filling in zeros as we go and I think that that would give us this expected output okay yeah that makes a lot of sense to me and so can you reiterate to me what the space time complexity and time complexity of this is yeah uh so the the space complexity is constant uh we're only using you know a couple of extra variables to keep track of information and we're using the uh input array that's given to us and the time complexity here is linear it's o n we do technically do like two passes kind of um but it's you know o of n at the end of the day right okay yeah so that's a lot better than the a couple of other approaches you initially proposed so why don't we try implementing it yeah sounds great uh so let's cover this up um let's start defining ourselves um a function um let's call it you know move move zeros um take data all right so we we need to start keeping track of multiple pointers so um let's call it something like index or something like that start it off at zero and then we iterate over each of the numbers in that array uh actually let's call this let's call this fill index just to make it a little clear I don't think we actually need the index when we're iterating over this array but yeah let's see um so what was our rule our rule was that uh if the number that we're at is not zero we put it to where we're keeping track of our data so um so if the number does not equal zero then we do something like data at fill index equals the number that we have um so this kind of pushes it Forward um the only last thing that's missing here is if we do that we have to shift that array index forward so till index plus equals 1 all right awesome um so I think that does the first half of what I was talking about was that it shifts all the elements in here first uh now we just need to do that last part which is filling the zeros at the end uh so let's say for remaining index uh in range so we're already where we need to be right like if if we kind of look at this initial example that we had the the left index that we wanted is kind of our starting point so let's actually do exactly that let's say fill index over here uh rather than starting from scratch up until the end of the array and what do we do in that case we just fill it with a zero um so yeah I think this should work and you know just comment it you know we fill the first partition and then for the second part um fill remainder with zeros okay with yeah um we should probably test this now yeah I think that's important what kind of test cases do you have in mind yeah I mean we we definitely want to test edge cases uh you know arrays with you know only zeros um maybe maybe no zeros uh situations where we have duplicate numbers perhaps um I think that that would that would make sense uh more General case like zeros at the beginning Zer only at the end and I guess the general scenario where we kind of have zeros well spread out like in like in this case M all right yeah um shall we write some unit tests yeah let's do it all right awesome so we do this we'll have move zeros of let's say um let's try that initial example that we have so 08 80 61 so this could be just for argument sake let's make sure that we have that work then we can try with a couple of other examples so let's say um Zer at the beginning let's say Zer at the end uh all zeros no zeros so let's try something like that so zeros at the beginning something like this zeros at the end uh only zeros and then only numbers something like this and let's say for argument sake just our long example that we had here because you know we love and cherish the examples that we started with so okay let's try that all right great uh so what we instead have to do is we have to take our data and then uh modify it in place so this is kind of an expected result uh so let's say data equals this and then we just do data and then print data at the end so this print data all right so a bunch of these If This Were a real unit testing framework this would be much nicer but yeah this and then one more for that last one great all right let's try that again all right move to the end move to the end move to the end great yeah this looks like uh what we expect so okay perfect uh so I think this is a great place to pause uh you really did a great job with this interview um but i' still love to hear from you if you were the interviewer how would you analyze this like uh what do you think went well and what do you think you would improve yeah yeah so uh I think what was good about the interview is that you know we took a structured approach to solving it where as always you want to ask clarifying questions and kind of build up to a solution um I think one thing that I could have done better when I was doing that is uh maybe be explicit when an approach that I'm suggesting is you know brute force uh like being more explicit with the interviewer about that uh you know backing it up with some sort of time or space complexity analysis uh preemptively uh and perhaps suggesting that we could do better than that I think that's always a good signal to the interviewer I just sort of posited a solution but uh you kind of prompted me back that maybe it wasn't as efficient um another thing that I think uh could have been uh a good hint in this thing or not a good hint but a good uh application here is that I tried a proposed approach against an example I wasn't sure if it would work uh and I think that that's always a good step to take before you jump into the code you want to try it against an example to ensure its correctness uh and hopefully as it did in this casee it kind of set ourselves set ourselves up with uh a good unit test case to do later um one more thing uh we can realize in retrospect is that we actually could have optimized this code a little bit uh we don't technically need to fill in uh at the end here with zeros uh we could technically just swap elements as we go uh which would actually just automatically push the zeros to the end uh and way uh we sort of realized at the end that we we were kind of left with numbers that we didn't need but uh in reality if we did some swapping this would have yielded us our solution at the very end so we don't need to do this extra um set of steps right yeah that's a clever observation so still linear but definitely a little bit more efficient um yeah okay so I agree with a lot of those points I do really like that you uh tested your logic on a lot of like concrete toy examples and it helps your thinking process and it also helps the interviewer understand how you're thinking about the problem so I found that really helpful uh and I like that your code was like very efficient and clear you didn't really start implementing until you were clear on what your algorithm was um yeah and I also like that you thought carefully about all of the different test cases that you wanted to try so like you came up with a really exhaustive set there weren't really any other test cases that I could even suggest because You' already covered so many of them so that was amazing as well um yeah and I think that's about all um again also really like the clarifying questions because I when I posed a question it was a little bit vague I hadn't mentioned for example that uh it needed to be in place or that you have to maintain the relative order of the non-zero elements so it was really smart that you asked those questions as well all right so uh thank you so much for being here with us today Simon uh and thanks everybody else for watching if you have any upcoming interviews good luck bye everyone [Music],Coding Mock Interview - Move All Zeros To End Of Array (with Google SWE) [56QSCo2gBfA].txt
Software Engineer @ Bloomberg 1, jma9hFQSCDk, Kind: captions Language: yeah I can hear you carry me yeah I'm doing all right wait how are you pretty good I'm pretty good I actually just found out that as a video interview so yeah okay it's okay is this your first time using this platform no I'm just before but from - three months ago so recent here okay I've used I've used other ones but this is my first time using this particular okay yeah okay are you ready software engineer over is looking for a new opportunity I'm looking for a new opportunity yeah yeah what about you I'm working recently in in Bloomberg London office okay yeah well okay yeah I'm in Bay Area California okay yeah okay cool thank you so it's about that I will start asking you first okay so as you see you want some time to read the question first yeah so it's a BST successor search yeah okay okay so in a binary search tree and inorder successor of the node is defined as the node with the smallest key greater than the key of the input node given a node yeah binary search tree you're asked to write a function find inorder successor that returns the inorder successor of input node if it but that has no inorder successor return nor yes so what what you need to make given I know you have to get the smallest node which have a smallest body withers and the given one it exists if it doesn't agree it just return on okay and in the existing code you have the struct for the node which you would code in Java yeah I'm gonna code in Java okay so in you have a class for node that contains the key and lift Android and you have access to the parent itself and the constructor takes a value for the key and for the MS which you need to file which is fine in order successors take same but node and return your node which is a target one and knowledge if it doesn't exist and you have to you have some logic for to insert but you don't need to take care about that okay I'm sorry can you say that last part again you don't need to care about the logic for the insert method okay the insert method yeah it doesn't matter for you okay even not you will not need something like that so all you need just editing right you could here in this part or problem okay and then so the input isn't the necessary of the route it could be any yeah it could be and you know something like the three example on the list okay yeah if I give a new something like knowing okay so I'm searching for the node which contains the element greater than nine and the same time is the smallest one so it will be eleven right okay so am I expecting when I give you nine as an input you got me the note which is eleven this one something the front if I got if I gave you fourteen you need to return the root which is twenty okay because if the first node greater than 14 I see okay so if I do have a nine I want to return eleven yes if I have a twelve I want to return fourteen yes right okay and I do have access to the parent nodes exactly how about to the way up there okay so just yeah going over a couple examples say you give me 1111 yeah then the in order would be twelve right exactly okay [Music] so I'm just kind of think of the different cases that we can have here okay so yeah let's just say it use 12 as an example it would be four so so if so if we're using 12 and we're going down the tree it has to be on the right side okay but think about it if I give you nine and there's no 14 there yeah it looks good yeah if you give me 12 and there's no 14 then the answer would be 20 right if I could be 12 yeah if you give me 12 and there's no 14 yeah it's that didn't exist then I would have to go up exactly yeah I would have to go up and then I would have to go I would have to check which side I'm coming from yes and if I'm coming yet from the right side then I would have to go up again yes and then that would be the answer okay it just seems like there's like a lot of different cases that we could have I think I think we have two cases right and you said you said it correctly first case which if I can give you nine I'm expecting you to turn 11 which seems that I will go down right right but in the other case if I give you 12 without having 14 I need to turn 20 which I need to go up right so think about it when I need to go down and when I need to go yeah I'll need to go down case one and then other cases I'll need to go up exactly so let's start with going down yeah when I need to go down okay yeah if you need to go down then you want to always go you want to check if there is a right node check if no dot right exists okay if it does exist then yeah you want to go down and then go all the way to the left if it exists right so think about it if I give you 12 without having 14 this is the same right I give you a note which doesn't have a right child so you need to go up not down not down right right right oh if you don't have a right note if you need to switch to the second case which is I will I will need to go up so maybe I will do so so the first case will be if right now it exists go down yes to the room to the right okay now let us think about something else if I gave you nine right yeah and you have a right node which is 12 which node you need to return you need to return 11 right yeah so you go down to the right and then at this point check if left exists and if it does I believe then you just want to go all the way you want to keep going to the left until you get to an old node okay and if it doesn't exist if it doesn't exist which mean if I give you nine yeah to turn 12 without having eleven right right right yeah so if it does so because basically you're just going you are still you're going to the right and then you are still going to the left until nothing exists so yeah if there's no 11 then you would just if you had like a loop it would just stop there exactly okay so if it if it exists go all the way left until no and I think that's and then you should be done at that point for this choice so I think once you do that then you're done yeah this yes I think yeah in this case yeah okay so then the other case when you need to go up yeah so let's think about if I give you 12 yeah without having 14 yeah then you have to go up yeah tell what you have to to go up and then you have to go up again right you have to go up and then you have to go up again until you get to 20 yes so when you're going up I think you want you need to check which side you're coming up from so if you're at nine once you go up you'll say if nine dot right equals the node that we're on then you go up again mm-hmm but let's say we're on a 114 yeah I agree with you I give you 14 there you will check you will check that you don't have a right right child so even so I will go up so you will start with 12 and you are coming from the right so it seems that you need to continue right yeah you need to continue we will continue then tell 9 right and you you're coming from 12 which is from the right right I would seem that you need also to continue right right up to 20 and you are coming from left this time then so it stopped and you need to return funny right right right so okay so in this case if you're coming from 11 you're again you see there's no right node yes sir then you go up to 12 yeah you check that you've came from the left so you know you're done exactly mmm okay let me write that down okay so if you yeah so if you're not coming from the right then you want to go to parent check which side you came from exactly so if you came from left side you want to return the parent okay if you came from right side go up again okay and then you always have the case where if you if you are out of say you're at the root and there is no parent okay then this will be covered right because if I give it one e first shake well well check if I have a right child which is a 25 so I will return it right but if I don't have 25 I would go to the second check which is I will try to get my parent yeah I would find that I don't have any theorem so I can return 20 directly right right yeah yeah sorry you have to do some kind of check to check your pair I think it will be included it will be included in the check a check which is you will do it here right because this part you will add you will do this part in while loop right and every time you check the parent if the parent is null so you need to stop right now right right let's do some coding okay so we have a given input node will say if so if input node yeah it does not equal null then maybe we'll do a recursive call where again we're just calling this on you will solve it in the recursive okay yeah I mean we could use pointers as well and have them go up and down yeah you can just let fit but okay if you prefer recursive just go ahead yeah okay so yeah so if like we said if right exists actually it might be easier to do it let's just yeah okay do this so input right is not equal no we want to call them you can you can't you can't recursive on the same mess up because if if the note to the right is exist right you need to use some different logic which is you need to get the most left node right so you need to write a separate method which can give an a note get the most left one right so I think I think you need you need to go here right here and just type a method which is get most left right and you can give it a node which is call it X anything okay and it's not responsible for getting the most left child right right so yeah you're just right if X dot last is not simply yeah it goes no then you'll just return X otherwise get most left X dot left but this way this check should be like that X and well here now even you can't do that because if you don't exit okay let's assume that you will start with I gave you I gave you nine okay so you will you will pass to this node the node twelve right and you will start rating so the first time you check is twelve dot left equal equal not know because they call eleven right so you would go here and at rate again R is eleven so and when you get you go to 1111 that left equally Cornelia okay cool it's hard it's working yeah cool so we will done with this method right yeah so here we need to do come to light up right right okay yeah that make sense cuz you're gonna go to the right and then you're gonna keep going to the left and he didn't return that right right okay so I think that covers the first case yeah the second well okay so yeah so we said we need to go up now so we'll say maybe we'll have another pointer Tara fronts okay a parent so so I guess so right now we're kind of doing it the iterative way yeah okay so yeah let's just do it like that then since okay okay so if we have if right does Michael know we'll just go to the right and then go all the way to the left yeah I think I think we can call it in a more make sense so we have parent right and we have here some node we can call it coil which is the currents node right right is the input node right now so we have child and we have parent what we need to do we need we are sure now we need to go up right right so we need to do with a creative way which is we need to do some while loop or something like that but by which condition you need to stop right rating right yeah what is all so this condition is if parent left equals child then you want to return parent then you want to return the a parent so what we need to do now we need to reverse this condition and put it inside while loop right yeah yeah because if the parent yeah because if this isn't true then I need I need to go up right we need to go up again exactly so if we change this one to be while and we do something like that right just right reversing what you said then you know if I'm not going from the lift so I need to go up right or parent because so we can we can just remove this part and instead of lift who can do it right exactly yeah well equals right then parent equals parent dot and exactly and for the child you need to set it first right then right child equals parent exactly and you need to just cover one extra check which you mention oh yeah before yeah because if it doesn't exist yeah right so we'll say let me think where we need to put it for a sec okay yeah I think we could just put it here if parent dot parent equals null then we're just returning null think think about the petition for the condition again if I give you let us make some debug debugging okay if I give you nine so here's a parent will be when you write the pair will be twenty yeah and the charge will be nine I will check with the parent to try it which is twelve sorry which is twenty to try it on if a little child know so I will I will go inside this four loop parent to parent equal equal null try it because that wainy the parent for twenty is not right so yeah well parents are right yes wait so parent Detroit equal equal child so parent is twenty yeah parent are right a doesn't equal child yeah okay let's make sense right so so well parent rate equals child sorry someone's at the door I think so yeah so so yeah so input so parents 20 child is not yeah so okay we can't we can't we can't make the plug in for this one let me do it again if it change no in Wis 14 and the parents name is 12 okay so we'll start from here with parent to try it which is 12 to try it equal equal 14 excuse me actually can you give me one second someone's at the door sorry about that okay all right sorry about okay no so the parent now is 12 okay and that the child is 14 okay why is it 400 yeah it's child 14 parents yeah and the parents Valley so I'm expecting from you to return 20 for me okay mm-hmm I'm expecting so we will start debugging the parent Detroit which is 12 Detroit equal equal child equal 14 years a true true so I will I will come here if Aaron to parent equal equal null no because it's equal to nine continued the child will be 12 for and now the parent will be nine right right I would continue again if no in Detroit equal equal child here's the true so I will come here if parent Oh Taryn which is 20 equal equal null no so I will continue the child will be knowing exactly and the parent will be 20 very funny yeah and I will come back if the parent Detroit which is 25 equal equal child which is 9 no so I will come here and I will turn parent right right so just working but I think there is some case it can be not work it let me think how we can how we can't break that so you see it do you see a particular case that won't work yeah I see a 1 if I give you the input node it's already null okay okay which I gave you already and I'll input not invalid input okay what do you mean like him like a no that's not a tree no no does I know this love itself is not it's not an invalid input nor it yeah so if you will do it here which is not Detroit it would be so an exception right yeah could we just do a check yeah so at the beginning we need to check if the input node not equal null or equal equal null you just returned anything right this will burn all right exactly and I'm thinking about the front case what if I think they're all the cases yeah yeah I think a smoking point yeah mmm but let me think about if we can break it okay yeah let me think you know I think it's will work okay what is the time complexity for this code so the time complexity [Music] I think it should be log of n okay why you love a plan well just from looking at it I know when we're going up the tree we're only looking at the nodes that are on that particular path and okay like if we want to trace it the other way around we know that we're only checking half of the tree each time and what is the height of the tree hmm well I guess if the height of the tree is and say we have say we just have like one say it just goes one way and everyone only has like a right or a left then yes oh yeah so in in the best case scenario the height for the point in search tree is log n right because it's a binary search tree but in the worst case scenario which is we only have known in a only one way which is only right only left we can have a chain which is called a chain problem and it would be a linear ID right so the time complexity in the worst case scenario would be order n but in amortized long time or the average running time it will be order log and as you mentioned and what base complexity the space complexity will be since we're not calling it recursively which it should just be constant space yeah I could you yeah you're done man well actually when we're doing get most left yeah then if we have like you said only if everything is to the left then yeah but in the worst case scenario you are not at rating through all of the nodes because you will to get this point you have you need to have at least one right node right yeah so yeah one right exactly exactly so it would be I minus one you know interviewer fossils are valid but I think for me constant ill will be a satisfied answer and this is what I have in my in my motherland and because we could write get most left the iterative approach where we just use a pointer and then it would be a no space but you can do that because if you want to do that you need you need extra space you need because you need to keep track with the most left node right yeah I mean you'd have the extra you'd have the pointer so oh yeah yeah just just just you need you need extra memory inside each node because you want H no two points the most lives node in same path but you can't do that man because you will prick another thing if you want to keep a pointer inside the node itself which can pull into the most left node inside the same path every time you insert a new node in the point a search tree you need to cope with the for test and update all of them again right so let me think if we back to the same question here in in in 12 well I'm just thinking in line 70 on this this function here can we just have a pointer that just goes all the way to the left until we hit node yeah that's a problem because if you insert a new node which will change the some order for some of the node you need to reorder the same right you need to really order this pointer in all the node right and which that will break the condition that we can insert in the binary search tree in log time right so it will violate another another conditions but okay okay cool all right sorry we can run it or are we just gonna I think I can on it it's running now okay you have some missing winter 1877 let me check that 77 Wow okay so if we just get rid of the house yeah or we can just go yeah okay an attorney and so you have expecting a line seventy-three what we have [Music] they're not a statement I said he was he had not found it yeah I don't know maybe let's try it again maybe we were both typing and maybe got messed up okay yeah it's running now I'm twerking okay cool cool
Software Engineer @ Bloomberg 2, 5xuvqBjRkok, Kind: captions Language: en given an array of unique character which is XYZ and string which is STR okay implement a function get shortest unique substring let's find the smallest substring of str containing all the characters in array okay return empty string gives house-training does not exist come up with some sake of constitution analyzer okay so if i have exploded in the array and I have this drink I need to return that Y X choose okay the last three character right below yeah okay because [Music] and another thing to keep in mind is that the characters in array are unique as well so you won't have any like X X Y Z it'll just be one carry on exactly mm-hm so we need to do something like if I start at rating through the string I will start twist X I all the way up to other check if the x axis exists in the array right well I think we can keep it in set or something like that okay if we have set if we convert this array to be a set and check if the X is exist inside the set yes so we need to continue if the y inside the set yes we need to continue and if Y so I decide but now we have to repeated character but it's okay it maybe it's maybe would be the answer right right so we need to ignore the Y and continue if that is the set right so the first answer we have now is from XY Y Z right and we need to continue okay so we need to consider it from the problem so now you get run into issue right because you have Y but there's nothing in your set anymore yeah yeah the solution I have in my mind is order n square but I think we can do it better yeah you can yeah you know yeah because if we if we have two pointer and we can window between Zampa it will be n square which is not optimal so I'm thinking are you thinking I'm just going through every single substring and checking yeah right as you mention but it will be impossible solved in n log n because we not we can't sort so it will be the linear or n square in us yeah so we need to move to linear which for any linear solution for that right okay so do you have a way of maybe how you can determine if the substring is valid if I can sorry if you can see how like the substring is valid like what would be how can you check for that like you said you go through and ya say your pointer is at 0 &amp; 4 yeah then what you do is okay yeah you go through X you take that out your to Y you take that out of the set you go to Z you take that out of the set you could do that I mean if you wanted to like create a copy of the set yeah and then check that's one way it could work yeah but it's complex maybe you can find something easier less complex maybe we need we need to convert posts of substring and array to something which can't be compared to each other to know to make sure that if it's equal to each other or not right okay so I'm thinking [Music] so how would you think that we could do this in an N approach like how would you iterate through the string yeah my problem is if we need to add trade through if we do if we need to solve it in an approach so we need to find a way to just make a comparison between the array and the substring in order 1 which is in constant time right so I'm thinking now how we can we have two things the first thing we need to how to divide how to divide the string two sub strings I can think how to can compare between the array in the string can understand time right so if they are unique and if we sum the character no it should not be unique you later can you say that last part again I'm thinking about some the character to each other and having as a representative as an integer you know because if they are unique XYZ will give me a number which is you were thinking okay I have some kind of code like I have good yeah yeah but yeah but then if you it's it's a gets a little difficult if you have repeated like XY Y Z yeah exactly yeah exactly in this case in this case it will not it may not work but I think we can we can do it right yeah if you want to keep track of repeating curve exactly if we can keep track with a fifth character yeah oh we can we could it will work right so if I have a fifth row as we go through the substring if I add in X to the set Y and if I have Y I would not added but if I have that I would add it and upper both of them if they are equal to each other so it works so now we can do that in linear time right because it's had adding and checking it's a constant time so yeah it will work but now we have another task which is we can divide the strain to substitute if you start with X Y Y Z and we consider that at a solution which don't fall right can you say that again if we start with X Y why's that right and we do the calculation and be considered as a solution so the solution we stands for we need to find a way how we need to start the second substring right right so you're saying we have X Y Z that's that's kind of our result at this yes exactly and then so how would you keep track of X and Z Oh Kyle you could use like two pointers right you can say yeah yeah like start equals zero yeah and then and equals at this point would be three yes exactly mm-hmm so yeah so say we do we have X Y Z we see okay that's a correct solution yes you added to result via then how how would we move forward yeah this is a question so so right now at this point we want to find a smaller string right yes so maybe we can move one of the pointers a certain way but yeah if we move one of the points that way so we move the X to be a Y so we'd have 1 Y and one with that so yeah so you're saying we have 1 and 3 so now it doesn't meet the constraints yeah so we need anyway the said really found the why he will skip the Y you will find that you would escape the said you would find the why you escape so why you will find the X finally so the result will be right so you have so you're moving your Antonia right yeah so at this point you're at 1 in 7 yeah you see that it doesn't meet the constraints because you have no you will you have x y&amp;z at this point so you know that it is a valid string yeah but it's not the best one but so I need I need to try to make it smaller right so I will start moving to one right yeah this one is working it will be linear time yes will be 2 3 4 yeah and then finally you get to 5 and yeah me that it is the best it's better than result and then you yeah of that think this one would work okay so now we have how we're gonna move we'll have like a window that we're moving down this yeah yeah okay now we need to know how to keep track of what we've seen it what we haven't seen yeah we need to we can do that using a hash map right you can use a hash map yeah that gives you yeah kaneki with the key would be the character which is a char and the vector would be how many times we found it in the substring we have so you have the count of each character yeah exactly because I need to know if I ever if I move the left cursor to the right which is moving the one starting from Y to be the start at five as you mentioned we need to know if I'm losing some character which is important for me if it doesn't matter to the descriptor right okay so yeah so when you move start forward you're gonna remove it from are you gonna decrement yes diplomat like I would decrement it from the hashmap if I reach zero so this is an invalid solution so I need to consider a new solution so I need to move the right cochin of the left one right right oh I think we can write solution for that okay do you wanna write like a pseudo code or do you want to you can start coding it's up to you know I think I can I can start coding it doesn't take much time okay oh let me divide it in a very small things so what we need to do now we need to have a method which we can give it a string and this method will calculate if we yeah but we need at some point to know if it's a valid solution or not so we need to okay okay so we need I would code in C++ let me get the easier okay so we need some method this method we can it can open an integral and can call it get help forget hash code okay and this string will break a string else okay okay FM ticker answer which is an HTTP deal and all it does is just a trading through restring okay and every time all it will do it will make I plus equal the representation for his drink so we we can make it as a Phi right and after finishing we can return runs right and here this one to be longer so okay so this is get the ASCII value yes something like all the hedge implementation for that string right we are so that with unique right mm-hmm okay okay getting the hash code for string so what we need to do here we meet initially to have two pointers one we can call it left and one we can call it right okay okay so initially we will have the left foot pointing to zero and the right one initially will point to also 0 so both of them are now starting with an X right before that we need to we need to get the hash representation for the given area right so if we can if we have vector of HR we can have an trigger for the target which is our target to get the highest representation and we can make a new pink giving it array if we have a constructor for the string which can take a backdrop character and just compare it to a string okay and just all see this one here so and here we need to call get hash and pressing this one here right okay so the target now is what we are seeking to let exactly so here let's start moving we need to start a trading so the condition which we need to take in consideration that foil okay let me first have a string we can call it anyway answer which is an antichain right the best answer which we can meet return at some point here need to make it an answer and what working we will have something and call it temp okay and here we the condition we need to stop that while J is a smaller than it's the other size okay because we are sure that the day sorry let's call it left okay no because no right the right one would be the fastest on the left right right because now what what we need to do now here we and we need also to define the hashmap so we need a map a map will be of char and Edgar and you can call it mm okay on each character what we need to do we need first to consider if we have a pallet string and if it not valid we need to check if it exists in the map or not and we need to update account for this char right so what we need to do now we need to get the current hashing for the substring which we have which we which we can our case here is only one character right so we will have integer which is current hash right it will be calling it hash or the string which we need to consider in sight temp right so we need here to make temp plus equal TR so every time we have from I to J so every time we need to increment J right so J I dreaming right yeah okay right so every time you're adding so temp is a 10mg sintering and then you're kind of building that string exactly so every time I will try to add a new one from the right exactly okay and I need to be at the current house I need here two cases I have two cases first one if the current hash is equal equal the target which I'm taking for so we are sure that the substring is valid right yeah I need I need I need to make some check I need here to do if the character we will add does not exist before in the substring we have right right so I actually have a question you know about the get hash method yeah so you are you're going through your current string and you're getting you're adding the ASCII value to it yeah so if you have some so like AAA would that be the same as a B or I guess let's do BBB and then ABC one of those be the same no no okay yeah okay we're gonna say yeah I agree with you but it depends because because I will not tend PPP okay I go your point yeah because would be 98 98 98 and then 97 98 99 yeah okay so okay okay okay so I mean there's a way that you can edit the get hash to do this I do like I mean you could still use it mm-hmm okay okay but I think I think the case you mentioned it can it can be handled right because no okay okay okay let's assume that they had this hash code we're turn a unique okay value for a cure yeah so now if we if we consider a new character what we need to check we need to check if this character I got was I was know this guy I was I was thinking to check something here with me saying we're adding a new character to the right to the substring so what we need to check that if this character will exist or not yeah I think that's what I need to check i I can't I think this this code can work and you case will not work if I will not take in consideration the repeated character inside temp right I don't need to I will not have a case which I can have a a and a PC because in temp I will not add a I would also I wouldn't only add an unique character right and because I have the window between left and right so it would work right so when you have XY Y Z are you going to just skip over lately yeah let me let me get back there with you if I have X Y Z in the first time with EDX okay so I will check here if I am not find strf I STR why not equal not equal and repent what I mean so I already considered xp4 right what what what I need to do I do if I consider X before so I don't need to add it to temp but I need to only eat increment it's counter inside the hashmap so I will make em of STR fi naught plus exactly so here we are going to have X but we not we are we are not we will not get here because we don't have it initially right we will back to this case again so we back to the else here and inside the else we need to insert it inside the map so we are going to map to make something like that here okay so here we have X with value 1 right after that what I need to I need to add this drink into temp so temp now contain on the X okay and this point I will I will try to get the current cash for the temp which is X if it equal equal current hash so I can consider it as an answer right so I need to know now the lens for the current answer which will be integral the current and you can call it answer which will be the left - right plus one okay and what we need to do now if grant answer this motor then enter the size which mean this is the better answer than the what we have before right we need now to get the substring between left and right right so the answer will be SPR got sub pink green right left and right okay okay and it's not smaller than the one we have should we do something no right we don't need to do something so let me continue and see what's happening next time I will come here right I will be and okay after finishing all of that need to increment the right so right prosperous okay so it's coming here back again the SDR of I will be pointing to why right so if the my hash map containing y know we're getting here so here we have also the Y will be pointing to one right and the temp now will be YX and we would get the hash code here it will not equal so we not do anything we will increment the right okay okay taking again we're now pointing to another Y so if the Y exists yes it exists so we will increment it so we have now the Y pointing to two and the temp is the same X Y right right so we with not getting anything from here we will increment right and now we have that so if that doesn't exist here so we will have here also that we can point into one and now we have we have X Y Zed right okay which is will be the same as a current hash with the same as target right so we will get in here the left is pointing to 0 and the right will pointing to 3 so it will be 3 minus 0 plus 1 which is 4 so the temp answer is 4 and the answer to size can we can set it to anything anything large okay okay so it doesn't matter so we can send to the border the maximum exchange does matter now so the for now will smaller than alpha to size so we consider the other answer right so the answer now containing X Y why is it right right so what we need to do now we need move the left cursor right right we need to make left plus plus and what what we need to do before that we need to decrement the last character from the hashmap and from the temp if it exists right which is destroyed right so what we need to do now what we need to do here we're not to make em from STR off left to make - - because we are sure that it's a positive number we need to comment it by one and the problem now we need to find the place for this character inside temp and remove it right because temp now have XYZ and what we need to do now we need to remove the X inside it right okay if it's unique we are sure that it will be the first character from the left if what is okay since temp is all unique right yeah okay so we are sure that is the first one from the left so what we need to do now we need to make temp equal crimp broad substring from one vamp so at minus 1 right I'm now back to be why why is it I'll just be Y Zed yeah Talia weather director okay why is that okay and after that really we decrement the left to the left now is pointing to one right and it will be cream on the right so the right well passing to the Y so with and whites exist here so why now well T is 3 and X Y that will be only X Y right right and it will not be the same we will decrement the right thing so we will have another Z so Z will be here is true and here we have X be 0 ok and we still have Y dad would recommend the Y again so the Y will be 4 ok and at some point which we're at the X we will add X to be here 1 and here we will have good solution which is why that X right mm-hmm and you would consider that as an answer but when we do left - right it will be 8 minus 1 will be 7 plus 1 which is 8 8 would not be smaller than the answer we have so we will skip this part ok once we escapes its part what we need to do now we need to try to make it small window right so in post cases we need to remove this one from here so what is there what is your left and right right now at this point as it is all right it's pointing to the last character which is X ok and the left is pointing to the first way which is at index 1 ok ok so what I need to do now I'm Nick this is the correct answer but it's not the best answer right right but yeah I mean I think it's it's ok ok so I will not I'm not getting here right this part will not be executed because the template answer will be greater than the answer now because tenth answer now and answer now is something like why why is that why that why X right the kind of answer yeah or just yeah answer and answer which is the best one now which we have is XY Y Zed ok what is a temp answer temp answer yeah tap answer is just yeah right so temp at this point temp answer is not less than answer dot size yeah okay so his part would not be executed yeah right so what we need to do now we need to try to find a past answer so we need to make the window narrow as much as we can so we need to remove the left cursor right all we need to get means else which is a problem here but yeah so right there on line 35 you are moving the left there but your see that it won't move because you're you want to get into this if statement okay yeah so in the house I will try to do something similar in this logic and we can separate it later okay what we need to do we need also do decrement the count for the most left character right and we need to update the temp by that but at this time we are not sure that the character is a most left one in the tempt you know because here we will have X which is temp yeah that's what camp is right now yeah but yeah if it it will go it will work this time but second time once really move the Y and Y and we need to remove the dead you know that is the most it's not the most recent one to the left right okay so we need so at this point temp answer is y Y Z X Y Z so then once you see a y yeah then you would want to you're trying to remove this right you know and then we'll get to the next one yeah well can't you can't you already since there is no Y maybe you could just skip over it no I know I know no no we need to check we need to check the count for intelligence I'd the hashmap right count is one we need to move it if it's more than one we don't need to remove anything from the tempie because we are sure that we have another why which is which is valid inside the temp right we need to check if M we are we are sure that it's a valid value so I'll show that Y is already exist so if it's the are got left have a greater value than 100k equal equal 1 because untrue that it will be at least once because if this is still a valid answer so if it's one which mean I need to remove it from the temp and I need also to remove it from the hashmap right to decrement from the hashmap first and after that I need by the way of the other do something like that here right and I need to update the left so at this point here I have M which is why that X right and I will check if STR dot left which is why if MF y equal equal 1 no because M of M of Y is 3 right or 4 we have it here so we will skip this part and you need only to know NEADS this is two things is we need to decrement advanced very complicated yeah it is yeah so if so I think maybe just once you see that the hash is equal to the target then you should always be moving to the left you should move be moving left one I think maybe that might make it a little easier okay once the current hash equals target then you know you're gonna be moving left plus plus so you don't need to okay multiple areas maybe that's something yeah okay okay okay yeah you can escape it because we are over the one no yeah I think you had a good it was a good idea actually I hadn't seen it solved like that before you know it's if you actually look at what the answer that they give me they use a yeah they use a hash map that keeps the count of all the characters yeah so it'll be like X maps to 0 y maps to 0 Z maps to 0 mm-hmm and then they also have a unique counter mm-hmm which equals 0 mm-hmm so they go through this string and then they see okay X yeah so they'll have like X is 1 and then they check if the unique counter is equal to array dot size so unique counter would be 1 at this point because X was 0 and then you add a Y then unique counter was 2 then you entered another why it's still 2 and then you add a Z and it's one and unique counter is three and then at this point you could add this string this would be like your result at this point yeah result equals yeah let's see XYZ and then once you get to and then you move to have the window and then you would move the window that start plus plus yeah or left plus plus like you had it young and then you would yeah we would remove the X and then unique honor would be to it's the same idea it's the same idea yeah it's the same idea same idea but by simply yeah yeah obviously the way they had they had it was simple yeah it might be simpler yeah okay I think it was a good attempt I mean yeah was a it was it's actually a Lee code problem I saw it it's a Lee code hard if you wanted to look at it yeah you know more you know for this problem I'm sorry the name for the problem only code s somewhere let's see let's see I'm trying to pull it up I think yeah it's called I think minimum window substring number 76 yeah number 76 [Music] hello I think I lost them
Software Engineer Manager @ Amazon Part 1, sUi0GTk2_lc, Kind: captions Language: en hello hello me yeah I can hear you can hear me yeah I can hear you great welcome your first practice on your new Bing I oh yeah it is okay cool well welcome I'll be conducting your practice interview here today this interview should last them on 30 35 min 40 minutes or so I'll start off by giving you a quick back myself and then I'll turn it over to you you can feel free to share as much as you want to share and then after all that we'll get into the actual interview itself okay sounds good so I mean industry for about 19 years I've worked on some furnace that's a mostly Brecon systems currently I'm a software development manager at Amazon so I'll turn over to you as much as you want sure sure so I guess I have a master's in computer science from Cal Poly that I and I graduated a couple years ago I also I did an internship at Amazon and then I worked for about over a year at Western Digital as a full-stack engineer for their internal tools team so yeah a lot of front-end as well as back-end just supporting different teams within the company and right now I'm interviewing for I'm interviewing for new positions okay sounds good why don't you go ahead and flick the language of your choice so it does plain text let's start from there okay I'm gonna use Java okay so while I clean all this up can you just tell me in one or two sentences very very quickly what grep does in Linux you know what correct resident minute yeah so grep looks for a certain word in within a file yep great so what I'm actually gonna ask you to do is actually implement some part of grep here in Java so let's say there's a function that returns an int array you can also choose to return them this 51 okay and it takes in two strings the string called haystack and the string called needle so essentially what you'll be doing is you'll be looking for the needle in his back so for example the pay haystack is something like this a b c BD d BB e DD d abcdefgh i unless a needle is a b c and what you would do is you would return all the indices in which you find the needle in the haystack and that above example you'd return 2 and 14 so the 2 would correspond to an index that belongs this ABC importantin would be for this ABC that officer to make them yeah i think so so essentially we're gonna have two strings as the input and then yeah we just return the starting in to see wherever we have a match yep exactly okay are we guaranteed that the needle is gonna be less than the haystack no you should handle all the educators and error conditions okay mmm all right so what I'm thinking is we can have a pointer pointing at the beginning of the haystack and then we can iterate through and then whenever we find a match in the first character then we can compare the rest of the needle within the haystack starting at that index and then if we have a match we just record that index and then we go all the way through until we get to the end of the string okay can you go into live with more detail how are you gonna compare the needle and the and that so those windows characters the needle and the window of characters so I guess I could have like a helper function and I pass in the needle as well as the haystack with the index that I'm gonna start out with the haystack and then I could do like a character by character I could either do the substring comparison or I could just do character by character okay and which one would be more efficient um probably doing the character by well I guess if we're talking about space complexity if we're doing a substring it's going to create a new string if I do a substring and then I guess for time complexity probably the same because it I'll still have to okay compare with character so it's all you baby better just did use the point of view right okay so if you already do that chaired by characters approach what would be the overall time and space complexity so the so the space complexity should be the Big O of the size of needle actually no sorry the space complexity should be constant because we're not adding any additional space and then yeah the time complexity will be the size of a stack the characters in haystack and then I think when we're doing a comparison from haystack and needle so every time we find a match we are doing a string by string comparison so I think would be like Big O of k plus R K times L where K a now are the size of haystack and needle okay sounds good why don't you go ahead and start on implementing this approach and then we'll take it from there okay that's done good to you sounds good so as we said we can read their return in an array or a list I'll just do a list and it's gonna be a list of integers I guess we'll just call it needle haystack so we're gonna have two strings and then we're gonna have a pointer so we'll do while P is less than so we have to make sure that once we get to say we get to like on the haystack once we get to like this second-to-last letter H we don't want it like we already know we're done because it's less than the size of needle so there's no way we could be a match so what we can do is we can do while P is less than haystack length - needle length and as you mentioned if needle is greater than haystack then we know we can't have any matches so then we could just return we can just return our empty list so let's create that list now turn results okay so so here in this wild look will help while P is less than H stacked length so if a stack here is we'll just say I don't know how many that is but we'll say if it's like 10 and then needle is ABC it'll be while P is less than seven so I think that should work so as I mentioned we're gonna go through and we're gonna see if if this haystack char at P equals needle char at zero then we'll do how it will have like a helper function here that will do a comparison of the strings and if it's true then we'll add it P to result yeah so I guess let's see I think I'm missing a parenthesis so that's for that mm I have an extra brace your side this one for the hip listen for the while and then this one should be for that right okay actually I have an extra one right there oh I see like that one there down there there okay so then yeah like I said we'll have a boolean function here and I guess we can make it private compare strings and it's gonna be static and then this one also needs to be static so we're gonna have our needle and then we'll say it's p2 equals zero and then we'll say so we'll do while P is less than or we'll do while p2 is less than needle dot length and then we're going to do the character by character comparison so p2 are ads all right sorry Pepe then we'll do increments and then once we get to the end we know that all the characters match and then we'll return true so then up here we can call that helper function so we'll say if so we'll say if compare strings needle haystack and P then we'll do resulted ad P and then finally we can return results okay so I think I'm done do I'm going to try and run that yeah go for it okay so we'll do so I guess what result and then I guess we'll try it with your sample here and then we'll print out results so alright let's run that and I think right here yeah and comment that out and looks like we might have an infinite loop so I think here I forgot the increment P right so so at the end of this statement will do a P plus plus so let's try that so 2 and 14 okay I think that's 0 1 2 and then 14 do I'm going to try and run it on some more use cases yeah go for it okay so so maybe we'll do it when yeah we'll have this one ABC be longer we'll do it on [Music] everyone there's no matches I'm glad so things should just be 2:14 and then it should be nothing after that right because these shouldn't have any matches maybe we'll do one I mean I guess I think that looks good unless you want me to tribe more cases by a couple of words I'm gonna okay and it looks like you're sending in your needle first that's right yeah yeah 0 1 2 3 ok cool so let's also try something with an empty needle yeah okay that might be causing ok so so we have an out-of-balance index 0 so so when we passing the needle we have an empty string so if we're doing needle dot length it's not greater than haystack that length so we'll say well P is greater than I guess 7-0 if haystack see okay so if we're doing we're doing haystack that char at 0 but that doesn't exist so when it tries to access it online 41 we get air yeah when it does needle that char at 0 it'll be there is no zero because there's no nothing so what we can do I guess is we could just I think the best way to handle that was just to be to do it check so actually I guess I want to ask you if we have an empty string as the needle does that mean that everything is a match or we or nothing as a match now what do you think would be the best especially about what what makes much sense to you I think it Shh well like in this case we have a bunch of bees if we have like an empty string and a bee I guess [Music] so I mean so are the indices pointing at a character are they pointing in the teeth yeah so I mean yes so the industry here was there is no really indicee so I guess I mean it doesn't really make sense to have the empty string that is in a haystack because the empty string is that I guess could we can consider a string itself yeah so yeah what would be so if what would be the best in cap there I think we can maybe just check it as a special case where if we say if needle dot length zero then we could just return will return the result so I guess okay we could even have it maybe in here it's not like to go zero or that hmm Oh oh dear okay I think okay it's just an pronounce yeah because we don't have any matches
Google SWE Mock Interview, 56QSCo2gBfA, Kind: captions Language: en given an integer array nums move all of the zeros to the end of it while maintaining the relative order of the non-zero [Music] elements hi everyone we're here today with Simon for another software engineering boach interview thanks so much for being here with us today Simon can you quickly introduce yourself yeah uh hi folks uh I'm Simon Ean and I'm a software engineer at Google uh in the past I've also built systems at Spotify and Bloomberg and interned at Etsy and for square and excited to be back for another mock awesome yeah I imagine you've had to do a lot of interviews then so I'm excited to see you use some of that experience here today um all right so let's get right into our question for today given an integer array nums move all of the zeros to the end of it while maintaining the relative order of the non-zero elements and before we get started be sure to click the link in the description to check out exponent software engineering interview course Acer interview with library of interview questions in-depth mock interviews on coding and system design and a peer-to-peer mock interview tool to practice yourself uh so I see here that we have an example input and its expected output we've sort of moved all the zeros to the end here yep um I guess I have a few questions uh can I use extra space for this problem as then can I return a new array for the solution that's a good question uh we would prefer if you could do this in place yeah I mean that's fair uh I think you know if we could use extra space my my high level thought here is that maybe we could go through the array and then fill our result array with the non zero integers first you know in order um and then we can just fill the rest with zeros until we kind of match the sizes but yeah um I I hear you right that sounds like a pretty good solution but unfortunately we've got to assume we don't have that extra storage sure yeah that makes sense um so another question I had uh will the array have duplicate values uh yeah you can assume it might have dupli at values sure yeah I mean I don't I don't think it should affect the ultimate algorithm but I think it's you know good to keep in mind potentially for examples or something like that test cases um so overall I think that one approach that could work is you know we go through the array that we're given um you know remove all the zeros as we go and then just add them back at the end I think that could potentially work um okay sure so what would the time complexity of that approach be yeah I think that's ultimately the problem you know removing an element from an array as an O of n operation uh it requires shifting over the remaining elements to fill the Gap so in the worst case for the overall algorithm we'd potentially be removing something about like n elements so I guess that would be o of n^2 overall mhm yeah yeah so I'm wondering if you can do better here yeah yeah we definitely can um I guess this idea is a little bit out there but I suppose we could sort the array um which would technically be faster than quadratic time it would be all of n log n um the only thing here is that we'd probably just need a custom comparator for the Sorting uh something like you know zeros are weighted as infinity or something like that so they get pushed to the end uh and all nonzeros are kind of I guess weighted the same um I think python which I'm going to use I think it also guarantees stable ordering for its sorting so and that's necessary for our problem but I think something like that could work too right yeah that's a good thing to mention that the stable ordering matters here in order to keep the non-zero elements in the same order right so um that sounds like it would work actually it's not so far out there uh what are some of the downsides of this approach yeah I mean I suppose that one down downside here is that it's kind of like a cute solution uh to this you know very particular problem uh it's it's not a very extensible solution if say you know the problem parameters were to change uh but I think that a bigger downside is that it actually might still be too inefficient my my gut says that there's probably like a linear you know oen solution here okay so what might that look like yeah I was thinking that one common pattern I could try applying here is something like a two-pointer approach uh so ultimately we want to move all the zeros over to the end uh or I guess perhaps a better way of thinking about it is you know we want to move all the nonzeros to the front of the array um so I suppose that we could so we could iterate over the array while also keeping track of where to put that sort of next nonzero value uh you know the earliest position that needs to be filled um I think that would ultimately end up being o of end time I do need to try it against an example though because I'm I'm not fully sure how many pieces of data to keep track of and you know if I'll actually get all the zeros at the end so so let's maybe uh try it against an example okay yeah CU I was just about to ask where the pointers are pointing right uh so so let's start with maybe a longer example than this one let me just kind of try an example where we have zeros kind of everywhere um so let's do Z four say another zero two 3 let add another zero for measure one Z okay um so if I have this input well ultimately want to get is 4 2 3 1 and then four four zeros yeah I think that makes sense um okay so so let's let's start kind of keeping track of our data so if we have something like this let's sort of set ourselves up with a you know left and right pointer and then kind of see where that takes us so if we want to start shifting all of the nonzero elements to the left we'll start here um you know what's the ultimate rule that we're looking for um if the value that we're at is not a zero we kind of have to shift it to the last existing position so this is a zero so we kind of do nothing so let's say for argument sake you know and this iteration our right pointer moves forward uh then we check what's happening at the right pointer this is a non zero so we fill that left pointer with whatever's at the right pointer so that four gets put over there okay that makes sense yeah yeah so just to make sure I'm understanding what you're doing so the left pointer is always going to point to where you want to store all the non the end of where you're storing all the nonzero elements and the right pointer just points to where you're currently iterating through the array yeah exactly like we're sort of moving that right pointer forward one at a time and then the left pointer should technically only shift when we're moving something there um so like in this case we took what was at the zeroth the first index and we moved it to what was in the first index the zeroth index okay got it right so so at this stage you know we move forward the right pointer like we did uh we also have to move the the left pointer actually so these both shift forward um we check what's here it's a zero so we keep iterating forward we check what's here it's a two so we want to put that where the left point is so that becomes a two um then we shift both of them uh because we just filled in uh what was at that left pointer again we have a nonzero value so this becomes a three so these both shift um this is a zero so we keep going forward uh at this point we have a one so we fill that we have over here a zero so we don't fill that and then I guess the right pointer goes beyond the limit of the array so we're kind of done um we're not technically done because I see now and this is kind of what was on my mind that we still need to fill the zeros at the end so I guess one last step after we do that iteration is we just kind of continue that left pointer forward filling in zeros as we go and I think that that would give us this expected output okay yeah that makes a lot of sense to me and so can you reiterate to me what the space time complexity and time complexity of this is yeah uh so the the space complexity is constant uh we're only using you know a couple of extra variables to keep track of information and we're using the uh input array that's given to us and the time complexity here is linear it's o n we do technically do like two passes kind of um but it's you know o of n at the end of the day right okay yeah so that's a lot better than the a couple of other approaches you initially proposed so why don't we try implementing it yeah sounds great uh so let's cover this up um let's start defining ourselves um a function um let's call it you know move move zeros um take data all right so we we need to start keeping track of multiple pointers so um let's call it something like index or something like that start it off at zero and then we iterate over each of the numbers in that array uh actually let's call this let's call this fill index just to make it a little clear I don't think we actually need the index when we're iterating over this array but yeah let's see um so what was our rule our rule was that uh if the number that we're at is not zero we put it to where we're keeping track of our data so um so if the number does not equal zero then we do something like data at fill index equals the number that we have um so this kind of pushes it Forward um the only last thing that's missing here is if we do that we have to shift that array index forward so till index plus equals 1 all right awesome um so I think that does the first half of what I was talking about was that it shifts all the elements in here first uh now we just need to do that last part which is filling the zeros at the end uh so let's say for remaining index uh in range so we're already where we need to be right like if if we kind of look at this initial example that we had the the left index that we wanted is kind of our starting point so let's actually do exactly that let's say fill index over here uh rather than starting from scratch up until the end of the array and what do we do in that case we just fill it with a zero um so yeah I think this should work and you know just comment it you know we fill the first partition and then for the second part um fill remainder with zeros okay with yeah um we should probably test this now yeah I think that's important what kind of test cases do you have in mind yeah I mean we we definitely want to test edge cases uh you know arrays with you know only zeros um maybe maybe no zeros uh situations where we have duplicate numbers perhaps um I think that that would that would make sense uh more General case like zeros at the beginning Zer only at the end and I guess the general scenario where we kind of have zeros well spread out like in like in this case M all right yeah um shall we write some unit tests yeah let's do it all right awesome so we do this we'll have move zeros of let's say um let's try that initial example that we have so 08 80 61 so this could be just for argument sake let's make sure that we have that work then we can try with a couple of other examples so let's say um Zer at the beginning let's say Zer at the end uh all zeros no zeros so let's try something like that so zeros at the beginning something like this zeros at the end uh only zeros and then only numbers something like this and let's say for argument sake just our long example that we had here because you know we love and cherish the examples that we started with so okay let's try that all right great uh so what we instead have to do is we have to take our data and then uh modify it in place so this is kind of an expected result uh so let's say data equals this and then we just do data and then print data at the end so this print data all right so a bunch of these If This Were a real unit testing framework this would be much nicer but yeah this and then one more for that last one great all right let's try that again all right move to the end move to the end move to the end great yeah this looks like uh what we expect so okay perfect uh so I think this is a great place to pause uh you really did a great job with this interview um but i' still love to hear from you if you were the interviewer how would you analyze this like uh what do you think went well and what do you think you would improve yeah yeah so uh I think what was good about the interview is that you know we took a structured approach to solving it where as always you want to ask clarifying questions and kind of build up to a solution um I think one thing that I could have done better when I was doing that is uh maybe be explicit when an approach that I'm suggesting is you know brute force uh like being more explicit with the interviewer about that uh you know backing it up with some sort of time or space complexity analysis uh preemptively uh and perhaps suggesting that we could do better than that I think that's always a good signal to the interviewer I just sort of posited a solution but uh you kind of prompted me back that maybe it wasn't as efficient um another thing that I think uh could have been uh a good hint in this thing or not a good hint but a good uh application here is that I tried a proposed approach against an example I wasn't sure if it would work uh and I think that that's always a good step to take before you jump into the code you want to try it against an example to ensure its correctness uh and hopefully as it did in this casee it kind of set ourselves set ourselves up with uh a good unit test case to do later um one more thing uh we can realize in retrospect is that we actually could have optimized this code a little bit uh we don't technically need to fill in uh at the end here with zeros uh we could technically just swap elements as we go uh which would actually just automatically push the zeros to the end uh and way uh we sort of realized at the end that we we were kind of left with numbers that we didn't need but uh in reality if we did some swapping this would have yielded us our solution at the very end so we don't need to do this extra um set of steps right yeah that's a clever observation so still linear but definitely a little bit more efficient um yeah okay so I agree with a lot of those points I do really like that you uh tested your logic on a lot of like concrete toy examples and it helps your thinking process and it also helps the interviewer understand how you're thinking about the problem so I found that really helpful uh and I like that your code was like very efficient and clear you didn't really start implementing until you were clear on what your algorithm was um yeah and I also like that you thought carefully about all of the different test cases that you wanted to try so like you came up with a really exhaustive set there weren't really any other test cases that I could even suggest because You' already covered so many of them so that was amazing as well um yeah and I think that's about all um again also really like the clarifying questions because I when I posed a question it was a little bit vague I hadn't mentioned for example that uh it needed to be in place or that you have to maintain the relative order of the non-zero elements so it was really smart that you asked those questions as well all right so uh thank you so much for being here with us today Simon uh and thanks everybody else for watching if you have any upcoming interviews good luck bye everyone [Music]